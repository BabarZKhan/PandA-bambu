<?xml version="1.0"?>
<technology>
  <library>
    <name>CS_COMPONENT</name>
    <cell>
      <name>fifio</name>
      <operation operation_name="fifio"/>
      <circuit>
        <component_o id="fifio">
          <parameter name="ADDR_WIDTH">3</parameter>
          <structural_type_descriptor id_type="fifio"/>
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2017 Politecnico di Milano</copyright>  
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors> 
          <license>PANDA_LGPLv3</license>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="data_in" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="rd_en" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="wr_en" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="full" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="empty" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="data_out" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="fifio data_in data_out ADDR_WIDTH" VERILOG_PROVIDED=
"parameter DEPTH = 2**ADDR_WIDTH;

  reg [ADDR_WIDTH-1:0] rd_addr; 
  reg [ADDR_WIDTH-1:0] wr_addr; 
  reg [BITSIZE_data_in-1:0] ram [DEPTH-1:0];
  reg [ADDR_WIDTH:0] status_cnt;  

  // initialization of the fifio all data = 0
  integer i; 
  initial begin 
    for (i=0; i&lt;DEPTH; i=i+1) begin 
      ram[i] = {BITSIZE_data_in{1'b0}}; 
    end
  end

  assign full = (status_cnt > DEPTH-1);
  assign empty = (status_cnt == 0);
  assign data_out = ram[rd_addr];   

  always @(posedge clock) begin
    if (!reset) begin 
      status_cnt &lt;= 0; 
      rd_addr &lt;= 0; 
      wr_addr &lt;= 0; 
    end else begin  
      if (rd_en &amp;&amp; !wr_en) begin 
        rd_addr &lt;= rd_addr +1; 
        if (status_cnt != 0) begin 
          status_cnt &lt;= status_cnt -1; 
        end
      end else if (wr_en &amp;&amp; !rd_en) begin 
        ram[wr_addr] &lt;= data_in;
        wr_addr &lt;= wr_addr +1;
        if (status_cnt != DEPTH) begin 
          status_cnt &lt;= status_cnt +1;
        end 
      end else if (wr_en &amp;&amp; rd_en) begin
        rd_addr &lt;= rd_addr +1;
        wr_addr &lt;= wr_addr +1;
        ram[wr_addr] &lt;= data_in;        
      end 
    end
  end"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>fifio_free</name>
      <operation operation_name="fifio_free"/>
      <circuit>
        <component_o id="fifio_free">
          <parameter name="ADDR_WIDTH">3</parameter>
          <structural_type_descriptor id_type="fifio_free"/>
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2017 Politecnico di Milano</copyright>  
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors> 
          <license>PANDA_LGPLv3</license>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="data_in" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="rd_en" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="wr_en" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="full" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="empty" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="data_out" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="fifio_free data_in data_out ADDR_WIDTH" VERILOG_PROVIDED=
"parameter DEPTH = 2**ADDR_WIDTH;

  reg [ADDR_WIDTH-1:0] rd_addr;
  reg [ADDR_WIDTH-1:0] wr_addr;
  reg [BITSIZE_data_in-1:0] ram [DEPTH-1:0];
  reg [ADDR_WIDTH:0] status_cnt;

  integer i; 
  initial begin 
    for (i=1; i&lt;DEPTH; i=i+1) begin 
      ram[i] = i; 
    end
  end

  assign full = (status_cnt > DEPTH-1);
  assign empty = (status_cnt == 0);

  assign data_out = ram[rd_addr];

  always @(posedge clock) begin
    if (!reset) begin 
      status_cnt &lt;= DEPTH-1; // fifio free is initiliazed full
      rd_addr &lt;= 1;   //slot 0 is running so is not considered as free - slot 0 assigned by reset of selector
      wr_addr &lt;= 0; 
    end else begin  
      if (rd_en &amp;&amp; !wr_en) begin 
        rd_addr &lt;= rd_addr +1; 
        if (status_cnt != 0) begin 
          status_cnt &lt;= status_cnt -1; 
        end
      end else if (wr_en &amp;&amp; !rd_en) begin 
        ram[wr_addr] &lt;= data_in;
        wr_addr &lt;= wr_addr +1;
        if (status_cnt != DEPTH) begin 
          status_cnt &lt;= status_cnt +1;
        end
      end else if (wr_en &amp;&amp; rd_en) begin
        rd_addr &lt;= rd_addr +1;
        wr_addr &lt;= wr_addr +1;
        ram[wr_addr] &lt;= data_in;        
      end 
    end
  end"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>rams_dist</name>
      <operation operation_name="rams_dist"/>
      <circuit>
        <component_o id="rams_dist">
          <parameter name="BITSIZE_MEM">1</parameter>
          <structural_type_descriptor id_type="rams_dist"/>
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2017 Politecnico di Milano</copyright>  
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors> 
          <license>PANDA_LGPLv3</license>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="in1" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="wenable" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="selector_register_file" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o> in1
          <NP_functionality LIBRARY="rams_dist in1 selector_register_file out1 BITSIZE_MEM " VERILOG_PROVIDED=
"reg [BITSIZE_in1-1:0] ram [BITSIZE_MEM-1:0];
  always @(posedge clock)
  begin
  if (wenable)
    ram[selector_register_file] &lt;= in1;
  end
  assign out1 = ram[selector_register_file];"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>register_SE_r</name>
      <operation operation_name="register_SE_r"/>
      <circuit>
        <component_o id="register_SE_r">
          <structural_type_descriptor id_type="register_SE_r"/>
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2017 Politecnico di Milano</copyright>  
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors> 
          <license>PANDA_LGPLv3</license>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="in1" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="we" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="register_SE_r in1 out1" VERILOG_PROVIDED= "reg [BITSIZE_out1-1:0] reg_out1;
  assign out1 = reg_out1;
  always @(posedge clock)
    if(!reset) begin
      reg_out1 &lt;={BITSIZE_out1{1'b0}};
    end else begin
      if (we) begin 
        reg_out1 &lt;= in1;
      end
    end
  initial begin 
    reg_out1 ={BITSIZE_out1{1'b0}};
  end"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>simple_dual_port_ram_single_clock</name>
      <operation operation_name="simple_dual_port_ram_single_clock"/>
      <circuit>
        <component_o id="simple_dual_port_ram_single_clock">
          <structural_type_descriptor id_type="simple_dual_port_ram_single_clock"/>
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2017 Politecnico di Milano</copyright>  
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors> 
          <license>PANDA_LGPLv3</license>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="we" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="data" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="read_addr" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="write_addr" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="out" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="simple_dual_port_ram_single_clock data addr out1" VERILOG_PROVIDED="reg [BITSIZE_data-1:0] q;
   reg [BITSIZE_data-1:0] ram[2**BITSIZE_addr-1:0];
      always @ (posedge clock) begin
         if (we)
            ram[write_addr] &lt;= data;
         q &lt;= ram[read_addr];
      end
   assign out=q;"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>fifo</name>
      <operation operation_name="fifo"/>
      <circuit>
        <component_o id="fifo">
          <structural_type_descriptor id_type="fifo"/>
          <parameter name="RAM_DEPTH">1</parameter>
          <parameter name="ADDR_WIDTH">1</parameter>
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2017 Politecnico di Milano</copyright>  
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors> 
          <license>PANDA_LGPLv3</license>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="data_in" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="data_out" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="empty" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="full" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="rd_en" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="wr_en" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="rd_cs" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="wr_cs" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <NP_functionality LIBRARY="fifo data_in data_out RAM_DEPTH ADDR_WIDTH" VERILOG_PROVIDED="parameter ADDR_WIDTH = 8;
parameter RAM_DEPTH = (1 &lt;&lt; ADDR_WIDTH);

reg [ADDR_WIDTH-1:0] wr_pointer;
reg [ADDR_WIDTH-1:0] rd_pointer;
reg [ADDR_WIDTH :0] status_cnt;
reg [BITSIZE_data_in-1:0] data_out ;
wire [BITSIZE_data_in-1:0] data_ram ;

assign full = (status_cnt > (RAM_DEPTH-1));
assign empty = (status_cnt == 0);

always @ (posedge clock or posedge reset)
begin : WRITE_POINTER
  if (reset) begin
    wr_pointer &lt;= 0;
  end else if (wr_cs &amp;&amp; wr_en ) begin
    wr_pointer &lt;= wr_pointer + 1;
  end
end

always @ (posedge clock or posedge reset)
begin : READ_POINTER
  if (reset) begin
    rd_pointer &lt;= 0;
  end else if (rd_cs &amp;&amp; rd_en ) begin
    rd_pointer &lt;= rd_pointer + 1;
  end
end

always  @ (posedge clock or posedge reset)
begin : READ_DATA
  if (reset) begin
    data_out &lt;= 0;
  end else if (rd_cs &amp;&amp; rd_en ) begin
    data_out &lt;= data_ram;
  end
end

always @ (posedge clock or posedge reset)
begin : STATUS_COUNTER
  if (reset) begin
    status_cnt &lt;= 0;
  end else if ((rd_cs &amp;&amp; rd_en) &amp;&amp; !(wr_cs &amp;&amp; wr_en) 
                &amp;&amp; (status_cnt != 0)) begin
    status_cnt &lt;= status_cnt - 1;
  end else if ((wr_cs &amp;&amp; wr_en) &amp;&amp; !(rd_cs &amp;&amp; rd_en) 
               &amp;&amp; (status_cnt != RAM_DEPTH)) begin
    status_cnt &lt;= status_cnt + 1;
  end
end
   
simple_dual_port_ram_single_clock #(.BITSIZE_data(BITSIZE_data_in),.BITSIZE_addr(BITSIZE_addr)) DP_RAM (.clock(clock), .write_addr(wr_pointer), .data(data_in), .we(wr_en), .read_addr (rd_pointer), .q(data_ram));"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>Counter</name>
      <operation operation_name="Counter"/>
      <circuit>
        <component_o id="Counter">  BITSIZE_value
          <structural_type_descriptor id_type="Counter"/>
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2017 Politecnico di Milano</copyright>  
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors> 
          <license>PANDA_LGPLv3</license>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="value" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="driver_lines" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o> 
          <NP_functionality LIBRARY="Counter value driver_lines" VERILOG_PROVIDED="
   reg [BITSIZE_value - 1 : 0] counter;
   reg [BITSIZE_value - 1 : 0] next_counter;
   reg [BITSIZE_value - 1 : 0] increment;

   always @(posedge clock or negedge reset) begin
      if (!reset)
        counter &lt;= {BITSIZE_value{1'b0}};
      else
        counter &lt;= next_counter;
   end

   assign value = counter;

   always @(*) begin
      next_counter = counter + increment;
   end

   integer i;
   always @(*) begin
      increment = {BITSIZE_value{1'b0}};
      for (i = 0; i &lt; BITSIZE_driver_lines; i = i+1) begin
         increment = increment + driver_lines[i];
      end
   end"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>CallDispatcher</name>
      <operation operation_name="CallDispatcher"/>
      <circuit>
        <component_o id="CallDispatcher">
          <structural_type_descriptor id_type="CallDispatcher"/>
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2017 Politecnico di Milano</copyright>  
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors> 
          <license>PANDA_LGPLv3</license>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="fifo_data_out" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="fifo_empty" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="worker_status" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="fifo_rd_cs" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="fifo_rd_en" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="request" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="selected_worker" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="CallDispatcher fifo_data_out worker_status request selected_worker" VERILOG_PROVIDED="
 reg fifo_rd_cs;
 reg fifo_rd_en;
 reg [WORKERS - 1 : 0] selected_worker;
 wire [WORKERS - 1 : 0] notFull;
 reg [BITSIZE_REQUEST - 1 : 0] request;
 wire available_workers;
 reg call_state;
 reg next_call_state;
 reg available_data;
 assign notFull = ~worker_status;
 always @ (posedge clock or negedge reset) begin : CALL_STATE_REGISTER
    if (!reset) begin // Beginning of autoreset for uninitialized flops
       call_state &lt;= 1'h0;  // End of automatics
    end
    else begin
       call_state &lt;= next_call_state;
    end
 end

 always @(posedge clock or negedge reset) begin
    if (!reset)
      available_data &lt;= 1'b0;
    else
      available_data &lt;= !fifo_empty;
 end

 assign available_workers = ~(&amp; worker_status);

 always @ (*) begin
    fifo_rd_cs = 1'b0;
    fifo_rd_en = 1'b0;
    next_call_state = 1'b0;
    request = {BITSIZE_REQUEST{1'b0}};
    selected_worker = {WORKERS{1'b0}};
    if (call_state == 1'b0) begin
       if (available_workers &amp; available_data) begin
          fifo_rd_cs = 1'b1;
          fifo_rd_en = 1'b1;
          next_call_state = 1'b1;
       end
    end
    else begin
       selected_worker = notFull &amp; (-notFull); // find the first 0 bit
       request = fifo_data_out;
    end
 end // always @ (*)

/* -----\/----- EXCLUDED -----\/-----
 wire available_data;
 assign available_data = ~fifo_empty;
-----/\----- EXCLUDED -----/\----- */"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>scheduler</name>
      <operation operation_name="scheduler"/>
      <circuit>
        <component_o id="scheduler">
          <structural_type_descriptor id_type="scheduler"/>
          <parameter name="NUM_TASKS">8</parameter>
          <parameter name="KERN_NUM">0</parameter>
          <parameter name="ADDR_ACC">2</parameter>
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2017 Politecnico di Milano</copyright>  
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors> 
          <license>PANDA_LGPLv3</license>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="IN_M_Rdata_ram" dir="IN" is_memory="1" is_global="1" is_extern="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="IN_M_DataRdy" dir="IN" is_memory="1" is_global="1" is_extern="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="IN_Min_tag" dir="IN" is_memory="1" is_global="1" is_extern="1" is_tag_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="IN_request_accepted" dir="IN" is_memory="1" is_global="1" is_extern="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="Mout_oe_ram" dir="IN" is_memory="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="Mout_we_ram" dir="IN" is_memory="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="Mout_addr_ram" dir="IN" is_memory="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="Mout_data_ram_size" dir="IN" is_memory="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1" is_size_bus="1"/>
          </port_o>
          <port_o id="Mout_Wdata_ram" dir="IN" is_memory="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="Mout_tag_ram" dir="IN" is_memory="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="done_scheduler" dir="IN" is_memory="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="suspension" dir="IN" is_memory="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="task_pool_end" dir="IN" is_memory="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="OUT_Mout_oe_ram" dir="OUT" is_memory="1" is_master="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="OUT_Mout_we_ram" dir="OUT" is_memory="1" is_master="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="OUT_Mout_addr_ram" dir="OUT" is_memory="1" is_master="1" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="OUT_Mout_data_ram_size" dir="OUT" is_memory="1" is_master="1" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="OUT_Mout_Wdata_ram" dir="OUT" is_memory="1" is_master="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="OUT_Mout_tag_ram" dir="OUT" is_memory="1" is_master="1" is_tag_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="Min_tag" dir="OUT" is_memory="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="M_Rdata_ram" dir="OUT" is_memory="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="M_DataRdy" dir="OUT" is_memory="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="request_accepted" dir="OUT" is_memory="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="done_request" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="selector_register_file" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="scheduler IN_M_Rdata_ram IN_M_DataRdy IN_Min_tag Mout_oe_ram Mout_we_ram Mout_addr_ram Mout_data_ram_size Mout_Wdata_ram Mout_tag_ram done_scheduler suspension task_pool_end OUT_Mout_oe_ram OUT_Mout_we_ram OUT_Mout_addr_ram OUT_Mout_data_ram_size OUT_Mout_Wdata_ram OUT_Mout_tag_ramMin_tag M_Rdata_ram M_DataRdy request_accepted done_request selector_register_file NUM_TASKS KERN_NUM ADDR_ACC"
          IP_COMPONENT="fifio, fifio_free, mem_scheduler" VERILOG_PROVIDED="
  parameter SIZE_IN=BITSIZE_Mout_oe_ram+BITSIZE_Mout_we_ram+BITSIZE_Mout_addr_ram+BITSIZE_Mout_data_ram_size+BITSIZE_Mout_Wdata_ram+BITSIZE_Mout_tag;

  reg done_request;
  reg [BITSIZE_M_DataRdy-1:0] M_DataRdy;
  reg [BITSIZE_selector_register_file-1:0] selector_register_file;

  parameter [2:0] S_0 = 3'd0,
                  S_1 = 3'd1,
                  S_2 = 3'd2,
                  S_3 = 3'd3,
                  S_4 = 3'd4;

  reg [2:0] _present_state, _next_state;
  wire [BITSIZE_selector_register_file-1:0] next_selector_register_file;
  wire fifo_empty_free; 
  wire [BITSIZE_selector_register_file-1:0] fifo_data_out_free;
  wire fifo_wait_empty;
  wire fifo_empty_ready;
  wire [BITSIZE_selector_register_file-1:0] fifo_data_out_ready;
  wire fifo_rd_en_ready;
  wire fifo_wr_en_ready;
  wire [BITSIZE_selector_register_file-1:0] fifo_wait_data_out;
  wire [SIZE_IN-1:0] data_out_mem_kern;
  wire [SIZE_IN-1:0] data_out_mem_par;
  wire [SIZE_IN-1:0] data_in_kern_mem;
  wire [SIZE_IN-1:0] data_in_par_mem;
  wire [SIZE_IN-1:0] temp; 
  reg [31:0] i;
  wire fifo_rd_en_free; 
  wire fifo_wr_en_free; 
  wire mux_fifo_sel;
  wire [BITSIZE_selector_register_file-1:0] old_selector;
  wire [BITSIZE_selector_register_file-1:0] new_selector;
  wire mux_switching_logic;
  wire fifo_full_free;
  wire [BITSIZE_M_DataRdy-1:0] M_DataRdy_next;
  wire done_request_next;
  wire [BITSIZE_selector_register_file-1:0] data_ready;
  wire selectorByMemory;

  fifio_free #(.DATA_WIDTH(BITSIZE_selector_register_file), .ADDR_WIDTH($clog2(NUM_TASKS) )) fifo_free(
  .full        (fifo_full_free),
  .empty       (fifo_empty_free),
  .data_out    (fifo_data_out_free),
  .clk         (clock),
  .rst         (reset),
  .rd_en       (fifo_rd_en_free),
  .wr_en       (fifo_wr_en_free),
  .data_in     (selector_register_file)); // just the selector can write the data_in of fifo_free

  fifio #(.DATA_WIDTH(BITSIZE_selector_register_file), .ADDR_WIDTH($clog2(NUM_TASKS))) fifo_ready(
  .full        (),
  .empty       (fifo_empty_ready),
  .data_out    (fifo_data_out_ready),
  .clk         (clock),
  .rst         (reset),
  .rd_en       (fifo_rd_en_ready),
  .wr_en       (fifo_wr_en_ready),  // when data is copied insert data of task ready on ready 
  .data_in     (IN_Min_tag[BITSIZE_selector_register_file-1:0]));    // data go into memory to say in which cell to write and here to say which task is now ready

  fifio #(.DATA_WIDTH(BITSIZE_selector_register_file), .ADDR_WIDTH($clog2(NUM_TASKS))) fifo_wait(
  .full (),  	         //used by arbiter
  .empty (fifo_wait_empty),         //used by arbiter
  .data_out (fifo_wait_data_out),
  .clk (clock),
  .rst (reset),
  .rd_en (IN_request_accepted),
  .wr_en (suspension),
  .data_in (selector_register_file));

  //if fifo ready empty but data from memory ready then use data from memory
  assign selectorByMemory = fifo_empty_ready &amp;&amp; IN_M_DataRdy;
  //next selector can be old ones or new depending on state of fifo and signal arriving
  assign next_selector_register_file = (mux_switching_logic)? new_selector : old_selector;
  //if signal to end or switch and there is at least one task that is ready or free then swith moreover if you are in S_2 (no free or ready and arrive a response in ready then switch
  assign mux_switching_logic= ((done_scheduler || suspension) &amp;&amp; ((!fifo_empty_ready || selectorByMemory) || (!fifo_empty_free &amp;&amp; !task_pool_end))) || ((_present_state==S_2 || _present_state==S_4) &amp;&amp; (!fifo_empty_ready || selectorByMemory));
  //new selector can be a old task suspended or a new ones
  assign new_selector = (mux_fifo_sel)? data_ready : fifo_data_out_free;
  assign data_ready = (selectorByMemory) ? IN_Min_tag[BITSIZE_selector_register_file-1:0] : fifo_data_out_ready;
  //if at least one task in ready and is true that arrive one signal or you are in S_2 (wait for fifo_ready to be not-empty) then use ready
  assign mux_fifo_sel = (done_scheduler || suspension || _present_state==S_2 || _present_state==S_4) &amp;&amp; (!fifo_empty_ready || selectorByMemory);
  //if reset start task is 0 otherwise old selector
  assign old_selector = (!reset)? {BITSIZE_selector_register_file{1'b0}} : selector_register_file;

  assign fifo_rd_en_free = mux_switching_logic &amp;&amp; !mux_fifo_sel;
  assign fifo_wr_en_free = done_scheduler &amp;&amp; (!fifo_empty_free || !fifo_empty_ready || selectorByMemory || task_pool_end);
  assign fifo_rd_en_ready = mux_fifo_sel &amp;&amp; !selectorByMemory;
  assign fifo_wr_en_ready = IN_M_DataRdy &amp;&amp; !(mux_fifo_sel &amp;&amp; selectorByMemory);

  mem_scheduler #(.addr_mem_kern(BITSIZE_selector_register_file), .addr_kern_mem(BITSIZE_selector_register_file), .addr_mem_par(BITSIZE_selector_register_file), .addr_par_mem(BITSIZE_selector_register_file), .BITSIZE_data_in_kern_mem(SIZE_IN), .BITSIZE_data_in_par_mem(SIZE_IN), .BITSIZE_data_out_mem_kern(SIZE_IN), .BITSIZE_data_out_mem_par(SIZE_IN)) mem_scheduler (
    .clock(clock),
    .reset(reset),
    .addr_mem_kern(selector_register_file),
    .addr_kern_mem(selector_register_file),
    .addr_mem_par(fifo_wait_data_out),
    .addr_par_mem(IN_Min_tag[BITSIZE_selector_register_file-1:0]),
    .we_kern_mem(suspension),
    .we_par_mem(IN_M_DataRdy),    //if ready 1 then write
    .data_in_kern_mem(data_in_kern_mem),
    .data_in_par_mem(data_in_par_mem), //remove addr_task-bits of tag
    .data_out_mem_kern(data_out_mem_kern), 
    .data_out_mem_par(data_out_mem_par));

  assign data_in_kern_mem = {IN_Mout_tag_ram,Mout_Wdata_ram,Mout_data_ram_size,Mout_addr_ram,Mout_we_ram,Mout_oe_ram};
  assign data_in_par_mem = {IN_Min_tag[BITSIZE_Mout_tag-1:BITSIZE_selector_register_file+KERN_NUM], {(BITSIZE_selector_register_file+KERN_NUM){1'b0}}, IN_M_Rdata_ram,{(BITSIZE_Mout_data_ram_size + BITSIZE_Mout_addr_ram + BITSIZE_Mout_we_ram + BITSIZE_Mout_oe_ram){1'b0}}};
  assign OUT_Mout_oe_ram=(data_out_mem_par[BITSIZE_Mout_oe_ram-1] &amp;&amp; !fifo_wait_empty);
  assign OUT_Mout_we_ram=(data_out_mem_par[BITSIZE_Mout_we_ram + BITSIZE_Mout_oe_ram-1] &amp;&amp; !fifo_wait_empty);
  assign OUT_Mout_addr_ram=data_out_mem_par[BITSIZE_Mout_addr_ram + BITSIZE_Mout_we_ram + BITSIZE_Mout_oe_ram-1:BITSIZE_Mout_we_ram + BITSIZE_Mout_oe_ram];
  assign OUT_Mout_data_ram_size=data_out_mem_par[BITSIZE_Mout_data_ram_size + BITSIZE_Mout_addr_ram + BITSIZE_Mout_we_ram + BITSIZE_Mout_oe_ram-1:BITSIZE_Mout_addr_ram + BITSIZE_Mout_we_ram + BITSIZE_Mout_oe_ram];
  assign OUT_Mout_Wdata_ram=data_out_mem_par[BITSIZE_Mout_Wdata_ram + BITSIZE_Mout_data_ram_size + BITSIZE_Mout_addr_ram + BITSIZE_Mout_we_ram + BITSIZE_Mout_oe_ram-1:BITSIZE_Mout_data_ram_size + BITSIZE_Mout_addr_ram + BITSIZE_Mout_we_ram + BITSIZE_Mout_oe_ram];
  assign OUT_Mout_tag_ram={data_out_mem_par[BITSIZE_Mout_tag + BITSIZE_Mout_Wdata_ram + BITSIZE_Mout_data_ram_size + BITSIZE_Mout_addr_ram + BITSIZE_Mout_we_ram + BITSIZE_Mout_oe_ram-1:ADDR_ACC + BITSIZE_selector_register_file+ BITSIZE_Mout_Wdata_ram + BITSIZE_Mout_data_ram_size + BITSIZE_Mout_addr_ram + BITSIZE_Mout_we_ram + BITSIZE_Mout_oe_ram],KERN_NUM,fifo_wait_data_out};

  assign M_Rdata_ram=data_out_mem_kern[BITSIZE_Mout_Wdata_ram + BITSIZE_Mout_data_ram_size + BITSIZE_Mout_addr_ram + BITSIZE_Mout_we_ram + BITSIZE_Mout_oe_ram-1:BITSIZE_Mout_data_ram_size + BITSIZE_Mout_addr_ram + BITSIZE_Mout_we_ram + BITSIZE_Mout_oe_ram];
  assign Min_tag=data_out_mem_kern[BITSIZE_Mout_tag + BITSIZE_Mout_Wdata_ram + BITSIZE_Mout_data_ram_size + BITSIZE_Mout_addr_ram + BITSIZE_Mout_we_ram + BITSIZE_Mout_oe_ram-1:BITSIZE_Mout_Wdata_ram + BITSIZE_Mout_data_ram_size + BITSIZE_Mout_addr_ram + BITSIZE_Mout_we_ram + BITSIZE_Mout_oe_ram];
  assign request_accepted= Mout_oe_ram||Mout_we_ram; //memory always not full so if oe=1 or we=1 i save your request

  always @(posedge clock) begin
    if (!reset) begin 
      _present_state &lt;= S_0;
    end else begin 
      _present_state &lt;= _next_state;
    end
  end

  always @(*)	//FSM of scheduler
    begin
      _next_state = S_0;
      case (_present_state)  

      S_0: begin 
        // initialization of fifo 
         if(!reset || task_pool_end) begin
            _next_state = S_0;
         end else begin
           _next_state = S_1;
         end
      end

      S_1: begin
        if (task_pool_end) begin
          if ((done_scheduler || suspension) &amp;&amp; (fifo_empty_ready &amp;&amp; !IN_M_DataRdy)) begin //if fifo ready empty and not ready
            _next_state = S_4;
          end else begin
            _next_state = S_3;
          end
        end else begin
          if (suspension &amp;&amp; (fifo_empty_ready &amp;&amp; !IN_M_DataRdy &amp;&amp; fifo_empty_free)) begin
            _next_state = S_2;
          end else begin
            _next_state = S_1; 
          end  
        end    
      end
        
      S_2: begin
        if (!fifo_empty_ready || IN_M_DataRdy) begin
          _next_state = S_1;
        end else begin
          _next_state = S_2;
        end
      end

      S_3: begin //wait only for Ready
        if ((done_scheduler || suspension) &amp;&amp; (fifo_empty_ready &amp;&amp; !IN_M_DataRdy)) begin
          _next_state = S_4;
        end else begin
          _next_state = S_3;
        end
      end

      S_4: begin //wait only for Ready
        if (!fifo_empty_ready || IN_M_DataRdy) begin
          _next_state = S_3;
        end else if (fifo_full_free) begin
          _next_state = S_0;
        end else begin
          _next_state = S_4;
        end
      end

      default: begin 	  
      _next_state = S_0;
      end
    endcase
  end

  always @(posedge clock) begin
    if (!reset) begin
      M_DataRdy &lt;= 1'b0;
    end else begin 
      M_DataRdy &lt;= M_DataRdy_next;
    end
  end

  always @(posedge clock) begin
    if (!reset) begin 
      done_request &lt;= 1'b0;
    end else begin 
      done_request &lt;= done_request_next;
    end
  end

  always @(posedge clock) begin
    if (!reset) begin 
      selector_register_file &lt;= {BITSIZE_selector_register_file{1'b0}};
    end else begin 
      selector_register_file &lt;= next_selector_register_file;
    end
  end

  assign M_DataRdy_next=fifo_rd_en_ready || (mux_fifo_sel &amp;&amp; selectorByMemory);
  assign done_request_next= fifo_rd_en_free || (done_scheduler &amp; fifo_empty_free &amp; fifo_empty_ready &amp; !selectorByMemory);"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>mem_scheduler</name>
      <operation operation_name="mem_scheduler"/>
      <circuit>
        <component_o id="mem_scheduler">
          <structural_type_descriptor id_type="mem_scheduler"/>
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2017 Politecnico di Milano</copyright>  
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors> 
          <license>PANDA_LGPLv3</license>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="we_kern_mem" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="we_par_mem" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="addr_mem_kern" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="addr_kern_mem" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="addr_mem_par" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="addr_par_mem" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="data_in_kern_mem" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="data_in_par_mem" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="data_out_mem_kern" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="data_out_mem_par" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="mem_scheduler addr_mem_kern addr_kern_mem addr_mem_par addr_par_mem data_in_kern_mem data_in_par_mem  data_out_mem_kern data_out_mem_par NUM_TASKS" VERILOG_PROVIDED=" 
  reg [BITSIZE_data_in_kern_mem-1:0] local_mem[NUM_TASKS-1:0]; 
 
  integer i; 
  initial begin 
    for (i=0; i&lt;NUM_TASKS; i=i+1) begin 
       local_mem[i] = {BITSIZE_data_in_kern_mem{1'b0}};
    end
  end

  always @(posedge clock) begin 
    if (we_kern_mem == 1'b1) begin 
      local_mem[addr_kern_mem] &lt;= data_in_kern_mem; // from the memory controller response    
    end 
    if (we_par_mem == 1'b1) begin
      local_mem[addr_par_mem] &lt;= data_in_par_mem;  
    end
  end

  assign data_out_mem_kern = local_mem[addr_mem_kern]; 
  assign data_out_mem_par = local_mem[addr_mem_par];"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>mem_ctrl_kernel</name>
      <operation operation_name="LOAD" bounded="0"/>
      <operation operation_name="STORE" bounded="0"/>
      <channels_type>MEM_ACC_CS</channels_type>
      <memory_ctrl_type>D00</memory_ctrl_type>
      <circuit>
        <component_o id="mem_ctrl_kernel">
          <structural_type_descriptor id_type="mem_ctrl_kernel"/>
          <parameter name="TAG_MEM_REQ">0</parameter>
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2017 Politecnico di Milano</copyright>  
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors> 
          <license>PANDA_LGPLv3</license>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="start_port" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="in1" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="in2" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="in3" dir="IN">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="in4" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="sel_LOAD" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="sel_STORE" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="done_port" dir="OUT">
            <structural_type_descriptor type="BOOL" size="1"/>
            </port_o>
          <port_o id="out1" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="M_Rdata_ram" dir="IN" is_memory="1" is_global="1" is_extern="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1"/>
          </port_o>
          <port_o id="Min_tag" dir="IN" is_memory="1" is_global="1" is_extern="1" is_tag_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1"/>
          </port_o>
          <port_o id="M_DataRdy" dir="IN" is_memory="1" is_global="1" is_extern="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="request_accepted" dir="IN" is_memory="1" is_global="1" is_extern="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="Mout_oe_ram" dir="OUT" is_memory="1" is_master="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="Mout_we_ram" dir="OUT" is_memory="1" is_master="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="Mout_addr_ram" dir="OUT" is_memory="1" is_master="1" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1"/>
          </port_o>
          <port_o id="Mout_data_ram_size" dir="OUT" is_memory="1" is_master="1" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1"/>
          </port_o>
          <port_o id="Mout_Wdata_ram" dir="OUT" is_memory="1" is_master="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1"/>
          </port_o>
          <port_o id="Mout_tag_ram" dir="OUT" is_memory="1" is_master="1" is_tag_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1"/>
          </port_o>
          <NP_functionality LIBRARY="mem_ctrl_kernel in1 in2 in3 in4 out1 M_Rdata_ram Min_tag M_DataRdy Mout_oe_ram Mout_we_ram Mout_addr_ram Mout_data_ram_size Mout_Wdata_ram Mout_tag_ram TAG_MEM_REQ" VERILOG_PROVIDED="
  assign done_port=((Min_tag==TAG_MEM_REQ) &amp;&amp; M_DataRdy[0]);  //if the tag is equal and ready=1 then its the right data
  assign Mout_Wdata_ram = ((sel_LOAD || sel_STORE) &amp;&amp; start_port) ? in1 :{BITSIZE_Mout_Wdata_ram{1'b0}};
  assign out1 = M_Rdata_ram;  
  assign Mout_addr_ram = ((sel_LOAD || sel_STORE) &amp;&amp; start_port) ? in2 :{BITSIZE_Mout_addr_ram{1'b0}};
  assign Mout_data_ram_size = ((sel_LOAD || sel_STORE) &amp;&amp; start_port) ? in3 :{BITSIZE_Mout_data_ram_size{1'b0}};
  assign Mout_oe_ram = sel_LOAD &amp;&amp; start_port;
  assign Mout_we_ram = sel_STORE &amp;&amp; start_port;
  assign Mout_tag_ram = ((sel_LOAD || sel_STORE) &amp;&amp; start_port) ? TAG_MEM_REQ :{BITSIZE_Mout_tag_ram{1'b0}};"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>memory_ctrl</name>
      <operation operation_name="memory_ctrl"/>
      <circuit>
        <component_o id="memory_ctrl">
          <structural_type_descriptor id_type="memory_ctrl"/>
          <parameter name="NUM_CHANNEL">2</parameter>
          <parameter name="NUM_ACC">4</parameter>
          <parameter name="NUM_TASKS">8</parameter>
          <parameter name="ADDR_TASKS">3</parameter>
          <parameter name="ADDR_ACC">2</parameter>
          <parameter name="NUM_BANK">4</parameter>
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2017 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="M_Rdata_ram" dir="IN" is_memory="1" is_global="1" is_extern="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="M_DataRdy" dir="IN" is_memory="1" is_global="1" is_extern="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="Min_tag" dir="IN" is_memory="1" is_global="1" is_extern="1" is_tag_bus="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="Min_tag_ram" dir="IN" is_memory="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="Min_oe_ram" dir="IN" is_memory="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="Min_we_ram" dir="IN" is_memory="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="Min_addr_ram" dir="IN" is_memory="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="Min_Wdata_ram" dir="IN" is_memory="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="Min_data_ram_size" dir="IN" is_memory="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="Mout_addr_ram" dir="OUT" is_memory="1" is_master="1" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="Mout_data_ram_size" dir="OUT" is_memory="1" is_master="1" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="Mout_Wdata_ram" dir="OUT" is_memory="1" is_master="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="Mout_oe_ram" dir="OUT" is_memory="1" is_master="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="Mout_we_ram" dir="OUT" is_memory="1" is_master="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="Mout_tag" dir="OUT" is_memory="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="Mout_DataRdy" dir="OUT" is_memory="1">
            <structural_type_descriptor type="INT" size="1"/>
          </port_o>
          <port_o id="Mout_Rdata_ram" dir="OUT" is_memory="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <port_o id="request_wait_accepted" dir="OUT" is_memory="1" is_master="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="occupancies" dir="OUT">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_o>
          <NP_functionality LIBRARY="memory_ctrl request_wait_accepted M_Rdata_ram M_DataRdy Mout_Rdata_ram Mout_DataRdy Mout_tag Min_oe_ram Min_we_ram Min_addr_ram Min_Wdata_ram Min_data_ram_size Min_tag_ram Mout_oe_ram Mout_we_ram Mout_addr_ram Mout_Wdata_ram Mout_data_ram_size occupancies"
          IP_COMPONENT="fifio, register_SE_r, PT_RR_FU, mux_pw_2, bus_merger" VERILOG_PROVIDED="
          //In order to be generated correctly num NUM_BANK>=NUM_CHANNEL and both of them must be a power of 2

          parameter FIFO_OUT =ADDR_TASKS+ADDR_ACC, FIFO_IN=ADDR_TASKS+ADDR_ACC;
          parameter SIZE_TOT_IN = BITSIZE_Mout_tag_ram+BITSIZE_Mout_Wdata_ram+BITSIZE_Mout_data_ram_size+BITSIZE_Mout_addr_ram+BITSIZE_Mout_we_ram+BITSIZE_Mout_oe_ram;
          parameter SIZE_TOT_OUT = BITSIZE_Mout_tag_ram+BITSIZE_M_Rdata_ram;
          parameter MSB_OUT_0=ADDR_ACC+ADDR_TASKS+BITSIZE_M_Rdata_ram-1;  //MSB=Most significant bit of addr_acc
          parameter MSB_OUT_1=ADDR_ACC+ADDR_TASKS+BITSIZE_M_Rdata_ram-$clog2(NUM_CHANNEL);  //MSB=Most significant bit of addr_acc
          parameter MSB_BANK_0=$clog2(NUM_BANK)+2+BITSIZE_Mout_we_ram+BITSIZE_Mout_oe_ram-1; //MSB=oe+we+2 bit (32 bit address)+log2(bank) -1
          parameter MSB_BANK_1=$clog2(NUM_BANK)-$clog2(NUM_CHANNEL)+2+BITSIZE_Mout_we_ram+BITSIZE_Mout_oe_ram; //MSB=oe+we+2 bit (32 bit address)+log2(bank)-log2(channel)
          parameter LSB_BANK_0=$clog2(NUM_BANK)-$clog2(NUM_CHANNEL)+2+BITSIZE_Mout_we_ram+BITSIZE_Mout_oe_ram-1; //MSB=oe+we+2 bit (32 bit address)+log2(bank)-log2(channel) -1
          parameter LSB_BANK_1=2+BITSIZE_Mout_we_ram+BITSIZE_Mout_oe_ram; //MSB=oe+we+2 bit (32 bit address)
          parameter RATIO=NUM_BANK/NUM_CHANNEL;

          // fifo in
          wire [NUM_BANK-1:0] IN_fifo_full;
          wire [NUM_BANK-1:0] IN_fifo_empty;
          wire [SIZE_TOT_IN*NUM_BANK-1:0] IN_fifo_data_out;
          wire [NUM_BANK-1:0] IN_fifo_rd_en;
          wire [NUM_BANK-1:0] IN_fifo_wr_en;
          wire [SIZE_TOT_IN*NUM_BANK-1:0] IN_fifo_data_in;

          // fifo out
          wire [NUM_BANK-1:0] OUT_fifo_full;
          wire [NUM_BANK-1:0] OUT_fifo_empty;
          wire [SIZE_TOT_OUT*NUM_BANK-1:0] OUT_fifo_data_out;
          wire [NUM_BANK-1:0] OUT_fifo_rd_en;
          wire [NUM_BANK-1:0] OUT_fifo_wr_en;
          wire [SIZE_TOT_OUT*NUM_BANK-1:0] OUT_fifo_data_in;

          //register status
          reg [3*NUM_BANK-1:0] in_status;
          wire [3*NUM_BANK-1:0] out_status;
          wire [SIZE_TOT_IN*NUM_BANK-1:0] out_reg;
          wire [NUM_CHANNEL-1:0] fifo_wait_empty;

          //to bank
          wire [BITSIZE_Mout_oe_ram*NUM_BANK-1:0] Mout_oe_ram_0;
          wire [BITSIZE_Mout_we_ram*NUM_BANK-1:0] Mout_we_ram_0;
          wire [BITSIZE_Mout_addr_ram*NUM_BANK-1:0] Mout_addr_ram_0;
          wire [BITSIZE_Mout_Wdata_ram*NUM_BANK-1:0] Mout_Wdata_ram_0;
          wire [BITSIZE_Mout_data_ram_size*NUM_BANK-1:0] Mout_data_ram_size_0;
          wire [BITSIZE_Mout_oe_ram*NUM_BANK-1:0] Mout_oe_ram_1;
          wire [BITSIZE_Mout_we_ram*NUM_BANK-1:0] Mout_we_ram_1;
          wire [BITSIZE_Mout_addr_ram*NUM_BANK-1:0] Mout_addr_ram_1;
          wire [BITSIZE_Mout_Wdata_ram*NUM_BANK-1:0] Mout_Wdata_ram_1;
          wire [BITSIZE_Mout_data_ram_size*NUM_BANK-1:0] Mout_data_ram_size_1;
          wire [NUM_BANK-1:0] valid_Out_reg_oe_we;
          wire [NUM_BANK-1:0] valid_Out_reg;
          wire [NUM_BANK-1:0] valid_Out_fifo;

          //rotation in
          wire [NUM_CHANNEL-1:0] fifo_notempty;
          wire [NUM_BANK-1:0] selector_mux_fifo_in;
          wire [NUM_BANK-1:0] arbiter_0_fifo_in;
          wire [SIZE_TOT_IN*NUM_BANK-1:0] exit_arbiter_0_fifo;
          wire [NUM_BANK-1:0] request_cycle_on;
          wire [NUM_BANK-1:0] request_accepted_by_fifo;

          //rotation out
          wire [NUM_BANK-1:0] selector_mux_OUT_fifo_out;
          wire [NUM_CHANNEL-1:0] rotation_fifo_out;
          wire [SIZE_TOT_IN*NUM_CHANNEL-1:0] data_in;
          wire [NUM_BANK-1:0] request_OUT_fifo;
          wire [NUM_BANK-1:0] request_out;
          wire [SIZE_TOT_OUT*NUM_CHANNEL-1:0] channel_out;

          // synthesis translate_off
          wire [NUM_BANK-1:0] bank_occ;
          Counter #(.BITSIZE_COUNTER(32), .DRIVERS(4)) CounterBank1(.value(occupancies), .clock(clock), .reset(reset), .driver_lines(bank_occ));
          // synthesis translate_on
          parameter S_0 = 3'b000,
                    S_1 = 3'b001,
                    S_2 = 3'b010,
                    S_3 = 3'b011,
                    S_4 = 3'b100,
                    S_5 = 3'b101;
          genvar i;
          generate
            for(i=0; i&lt;NUM_BANK; i=i+1)
            begin
              assign bank_occ[i]=(valid_Out_reg_oe_we[i] || valid_Out_fifo[i] || M_DataRdy[i]);

              // IN - I am putting data from parallel
              fifio #(.DATA_WIDTH(SIZE_TOT_IN), .ADDR_WIDTH(FIFO_IN)) IN_fifo (.full (IN_fifo_full[i]), .empty (IN_fifo_empty[i]), .data_out (IN_fifo_data_out[SIZE_TOT_IN*(i+1)-1:SIZE_TOT_IN*i]), .clk (clock), .rst (reset), .rd_en (IN_fifo_rd_en[i]), .wr_en (IN_fifo_wr_en[i]), .data_in (IN_fifo_data_in[SIZE_TOT_IN*(i+1)-1:SIZE_TOT_IN*i]));

              //OUT - I am putting data from memory
              fifio #(.DATA_WIDTH(SIZE_TOT_OUT), .ADDR_WIDTH(FIFO_OUT)) OUT_fifo_0 (.full (OUT_fifo_full[i]), .empty (OUT_fifo_empty[i]), .data_out (OUT_fifo_data_out[SIZE_TOT_OUT*(i+1)-1:SIZE_TOT_OUT*i]), .clk (clock), .rst (reset), .rd_en (OUT_fifo_rd_en[i]), .wr_en (OUT_fifo_wr_en[i]), .data_in (OUT_fifo_data_in[SIZE_TOT_OUT*(i+1)-1:SIZE_TOT_OUT*i]));

              //register of data that is connected with memory (blocking)
              register_SE_r #(.BITSIZE_in1(SIZE_TOT_IN), .BITSIZE_out1(SIZE_TOT_IN)) register_status(.clock(clock), .reset(reset), .in1(IN_fifo_data_out[SIZE_TOT_IN*(i+1)-1:SIZE_TOT_IN*i]), .wenable(valid_Out_fifo[i]), .out1(out_reg[SIZE_TOT_IN*(i+1)-1:SIZE_TOT_IN*i]));

              //register status of each bank of memory
              register_SE_r #(.BITSIZE_in1(3), .BITSIZE_out1(3)) register_0(.clock(clock), .reset(reset), .in1(in_status[3*(i+1)-1:3*i]), .wenable(1'b1), .out1(out_status[3*(i+1)-1:3*i]));

              //fifo that accept a request from parallel write, the second arbiter is 1
              assign request_accepted_by_fifo[i]=(IN_fifo_wr_en[i] &amp;&amp; !selector_mux_fifo_in[i] &amp;&amp; arbiter_0_fifo_in[i]);

              // IN_fifo_data_in can be output of IN_fifo_data_out or data from arbiter_0 (HIGH LEVEL)
              assign IN_fifo_data_in[SIZE_TOT_IN*(i+1)-1:SIZE_TOT_IN*i] = (selector_mux_fifo_in[i]) ? IN_fifo_data_out[SIZE_TOT_IN*((i+RATIO)%NUM_BANK+1)-1:SIZE_TOT_IN*((i+RATIO)%NUM_BANK)] : exit_arbiter_0_fifo[SIZE_TOT_IN*(i+1)-1:SIZE_TOT_IN*i];

              // exit_arbiter_0 can be output of IN_fifo_data_out itself or data from channel (LOW LEVEL)
              assign exit_arbiter_0_fifo[SIZE_TOT_IN*(i+1)-1:SIZE_TOT_IN*i] = (arbiter_0_fifo_in[i]) ? data_in[SIZE_TOT_IN*(i/RATIO+1)-1:SIZE_TOT_IN*(i/RATIO)] : IN_fifo_data_out[SIZE_TOT_IN*(i+1)-1:SIZE_TOT_IN*i];

              //write on fifo if not full and or there is a real request from another fifo, a rotation or data from channel
              assign IN_fifo_wr_en[i]=(selector_mux_fifo_in[i] || arbiter_0_fifo_in[i] || request_cycle_on[i]);

              //request from channel (valid only if fifo not full)
              assign arbiter_0_fifo_in[i]=(fifo_notempty[i/RATIO] &amp;&amp; !IN_fifo_full[i] &amp;&amp; data_in[SIZE_TOT_IN*(i/RATIO)+LSB_BANK_0:SIZE_TOT_IN*(i/RATIO)+LSB_BANK_1]==(i%RATIO));

              //if fifo_in opposite wants to copy data on correct fifo then do it only if destination not full
              assign selector_mux_fifo_in[i]=(!IN_fifo_empty[(i+RATIO)%NUM_BANK] &amp;&amp; IN_fifo_data_out[SIZE_TOT_IN*((i+RATIO)%NUM_BANK)+MSB_BANK_0:SIZE_TOT_IN*((i+RATIO)%NUM_BANK)+MSB_BANK_1]!=(((i+RATIO)%NUM_BANK)/RATIO) &amp;&amp; !IN_fifo_full[i]);

              //read if there is a write in output but its not from a different fifo, if write on a different fifo, if rotating
              assign IN_fifo_rd_en[i]= selector_mux_fifo_in[(i+RATIO)%NUM_BANK] || (request_cycle_on[i] &amp;&amp; !arbiter_0_fifo_in[i] &amp;&amp; !selector_mux_fifo_in[i]) || valid_Out_fifo[i];

              //cycle if fifo not empty, state is S_3, but copy data on another fifo and data from channal are false, data is store but not atomic, data il load atomic
              assign request_cycle_on[i]=!IN_fifo_empty[i] &amp;&amp; (out_status[3*(i+1)-1:3*i]==3'b011 || out_status[3*(i+1)-1:3*i]==3'b100 || out_status[3*(i+1)-1:3*i]==3'b101) &amp;&amp; !selector_mux_fifo_in[(i+RATIO)%NUM_BANK] &amp;&amp; ((IN_fifo_data_out[SIZE_TOT_IN*(i+1)-2] &amp;&amp; IN_fifo_data_out[SIZE_TOT_IN*i+BITSIZE_Mout_oe_ram-1]) || (!IN_fifo_data_out[SIZE_TOT_IN*(i+1)-2] &amp;&amp; IN_fifo_data_out[SIZE_TOT_IN*i+BITSIZE_Mout_we_ram+BITSIZE_Mout_oe_ram-1]));

              //FSM for the state of the register
              always @(*) begin
                case(out_status[3*(i+1)-1:3*i])
                  S_0: begin
                    if (!IN_fifo_empty[i] &amp;&amp; IN_fifo_data_out[SIZE_TOT_IN*i+MSB_BANK_0:SIZE_TOT_IN*i+MSB_BANK_1]==(i/RATIO)) begin
                      if(IN_fifo_data_out[SIZE_TOT_IN*(i+1)-2] &amp;&amp; IN_fifo_data_out[SIZE_TOT_IN*i+BITSIZE_Mout_oe_ram-1]) begin
                        in_status[3*(i+1)-1:3*i]=S_4;        //status is busy rotate
                      end
                      else begin
                        in_status[3*(i+1)-1:3*i]=S_1;        //status is busy
                      end
                    end
                    else begin
                      in_status[3*(i+1)-1:3*i]=S_0;
                    end
                  end
                  S_1: begin
                    if(!M_DataRdy[i]) begin
                      in_status[3*(i+1)-1:3*i]=S_1;
                    end
                    else begin
                      if(!request_OUT_fifo[(i+RATIO)%NUM_BANK] &amp;&amp; !OUT_fifo_full[i]) begin  //if ready, no request to rotate and fifo not full then free
                        in_status[3*(i+1)-1:3*i]=S_0;
                      end
                      else begin
                        in_status[3*(i+1)-1:3*i]=S_2;
                      end
                    end
                  end
                  S_2: begin
                    if(!request_OUT_fifo[(i+RATIO)%NUM_BANK] &amp;&amp; !OUT_fifo_full[i]) begin
                      in_status[3*(i+1)-1:3*i]=S_0;
                    end
                    else begin
                      in_status[3*(i+1)-1:3*i]=S_2;
                    end
                  end
                  S_3: begin
                    if (!IN_fifo_empty[i] &amp;&amp; IN_fifo_data_out[SIZE_TOT_IN*i+MSB_BANK_0:SIZE_TOT_IN*i+MSB_BANK_1]==(i/RATIO) &amp;&amp; !request_cycle_on[i]) begin
                      if(IN_fifo_data_out[SIZE_TOT_IN*(i+1)-2] &amp;&amp; IN_fifo_data_out[SIZE_TOT_IN*i+BITSIZE_Mout_we_ram+BITSIZE_Mout_oe_ram-1]) begin
                        in_status[3*(i+1)-1:3*i]=S_1;        //status is busy
                      end
                      else begin
                        in_status[3*(i+1)-1:3*i]=S_4;        //status is busy rotate
                      end
                    end
                    else begin
                      in_status[3*(i+1)-1:3*i]=S_3;
                    end
                  end
                  S_4: begin
                    if(!M_DataRdy[i]) begin
                      in_status[3*(i+1)-1:3*i]=S_4;
                    end
                    else begin
                      if(!request_OUT_fifo[(i+RATIO)%NUM_BANK] &amp;&amp; !OUT_fifo_full[i]) begin  //if ready, no request to rotate and fifo not full then free
                        in_status[3*(i+1)-1:3*i]=S_3;
                      end
                      else begin
                        in_status[3*(i+1)-1:3*i]=S_5;
                      end
                    end
                  end
                  S_5: begin
                    if(!request_OUT_fifo[(i+RATIO)%NUM_BANK] &amp;&amp; !OUT_fifo_full[i]) begin
                      in_status[3*(i+1)-1:3*i]=S_3;
                    end
                    else begin
                      in_status[3*(i+1)-1:3*i]=S_5;
                    end
                  end
                  default: begin
                    in_status[3*(i+1)-1:3*i]=S_0;
                  end
                endcase
              end

              //OUT PART

              //valid output only if fifo not empty and state is 00 and data is correct, or status is 01 and not ready, or status is 11 data correct, no rotation and fifo not empty
              assign valid_Out_reg_oe_we[i]=((out_status[3*(i+1)-1:3*i]==3'b001 || out_status[3*(i+1)-1:3*i]==3'b100) &amp;&amp; !M_DataRdy[i]);
              assign valid_Out_reg[i]= out_status[3*(i+1)-1:3*i]==3'b001 || out_status[3*(i+1)-1:3*i]==3'b100 || out_status[3*(i+1)-1:3*i]==3'b010 || out_status[3*(i+1)-1:3*i]==3'b101;

              //valid output only if fifo not empty and state is 00 and data is correct, or status is 01 and not ready, or status is 11 data correct, no rotation and fifo not empty
              assign valid_Out_fifo[i]=((out_status[3*(i+1)-1:3*i]==3'b000 &amp;&amp; !IN_fifo_empty[i] &amp;&amp; IN_fifo_data_out[SIZE_TOT_IN*i+MSB_BANK_0:SIZE_TOT_IN*i+MSB_BANK_1]==(i/RATIO)) || (out_status[3*(i+1)-1:3*i]==3'b011 &amp;&amp; !IN_fifo_empty[i] &amp;&amp; IN_fifo_data_out[SIZE_TOT_IN*i+MSB_BANK_0:SIZE_TOT_IN*i+MSB_BANK_1]==(i/RATIO) &amp;&amp; !request_cycle_on[i]));

        //output send out by module
              assign Mout_oe_ram_0[i]=(out_reg[SIZE_TOT_IN*i+BITSIZE_Mout_oe_ram-1] &amp; {BITSIZE_Mout_oe_ram{valid_Out_reg_oe_we[i]}});
              assign Mout_we_ram_0[i]= (out_reg[SIZE_TOT_IN*i+BITSIZE_Mout_we_ram + BITSIZE_Mout_oe_ram-1] &amp; {BITSIZE_Mout_we_ram{valid_Out_reg_oe_we[i]}});
              assign Mout_addr_ram_0[BITSIZE_Mout_addr_ram*(i+1)-1:BITSIZE_Mout_addr_ram*i]= (out_reg[SIZE_TOT_IN*i+BITSIZE_Mout_addr_ram + BITSIZE_Mout_we_ram + BITSIZE_Mout_oe_ram-1:SIZE_TOT_IN*i+BITSIZE_Mout_we_ram + BITSIZE_Mout_oe_ram] &amp; {BITSIZE_Mout_addr_ram{valid_Out_reg[i]}});
              assign Mout_data_ram_size_0[BITSIZE_Mout_data_ram_size*(i+1)-1:BITSIZE_Mout_data_ram_size*i]= (out_reg[SIZE_TOT_IN*i+BITSIZE_Mout_data_ram_size + BITSIZE_Mout_addr_ram + BITSIZE_Mout_we_ram + BITSIZE_Mout_oe_ram-1:SIZE_TOT_IN*i+BITSIZE_Mout_addr_ram + BITSIZE_Mout_we_ram + BITSIZE_Mout_oe_ram] &amp; {BITSIZE_Mout_data_ram_size{valid_Out_reg[i]}});
              assign Mout_Wdata_ram_0[BITSIZE_Mout_Wdata_ram*(i+1)-1:BITSIZE_Mout_Wdata_ram*i]= (out_reg[SIZE_TOT_IN*i+BITSIZE_Mout_Wdata_ram + BITSIZE_Mout_data_ram_size + BITSIZE_Mout_addr_ram + BITSIZE_Mout_we_ram + BITSIZE_Mout_oe_ram-1:SIZE_TOT_IN*i+BITSIZE_Mout_data_ram_size + BITSIZE_Mout_addr_ram + BITSIZE_Mout_we_ram + BITSIZE_Mout_oe_ram] &amp; {BITSIZE_Mout_Wdata_ram{valid_Out_reg[i]}});

          //output send out by module
              assign Mout_oe_ram_1[i]=(IN_fifo_data_out[SIZE_TOT_IN*i+BITSIZE_Mout_oe_ram-1] &amp; {BITSIZE_Mout_oe_ram{valid_Out_fifo[i]}});
              assign Mout_we_ram_1[i]=(IN_fifo_data_out[SIZE_TOT_IN*i+BITSIZE_Mout_we_ram + BITSIZE_Mout_oe_ram-1] &amp; {BITSIZE_Mout_we_ram{valid_Out_fifo[i]}});
              assign Mout_addr_ram_1[BITSIZE_Mout_addr_ram*(i+1)-1:BITSIZE_Mout_addr_ram*i]=(IN_fifo_data_out[SIZE_TOT_IN*i+BITSIZE_Mout_addr_ram + BITSIZE_Mout_we_ram + BITSIZE_Mout_oe_ram-1:SIZE_TOT_IN*i+BITSIZE_Mout_we_ram + BITSIZE_Mout_oe_ram] &amp; {BITSIZE_Mout_addr_ram{valid_Out_fifo[i]}});
              assign Mout_data_ram_size_1[BITSIZE_Mout_data_ram_size*(i+1)-1:BITSIZE_Mout_data_ram_size*i]=(IN_fifo_data_out[SIZE_TOT_IN*i+BITSIZE_Mout_data_ram_size + BITSIZE_Mout_addr_ram + BITSIZE_Mout_we_ram + BITSIZE_Mout_oe_ram-1:SIZE_TOT_IN*i+BITSIZE_Mout_addr_ram + BITSIZE_Mout_we_ram + BITSIZE_Mout_oe_ram] &amp; {BITSIZE_Mout_data_ram_size{valid_Out_fifo[i]}});
              assign Mout_Wdata_ram_1[BITSIZE_Mout_Wdata_ram*(i+1)-1:BITSIZE_Mout_Wdata_ram*i]=(IN_fifo_data_out[SIZE_TOT_IN*i+BITSIZE_Mout_Wdata_ram + BITSIZE_Mout_data_ram_size + BITSIZE_Mout_addr_ram + BITSIZE_Mout_we_ram + BITSIZE_Mout_oe_ram-1:SIZE_TOT_IN*i+BITSIZE_Mout_data_ram_size + BITSIZE_Mout_addr_ram + BITSIZE_Mout_we_ram + BITSIZE_Mout_oe_ram] &amp; {BITSIZE_Mout_Wdata_ram{valid_Out_fifo[i]}});

              //if there is a block on out_channel that has incorrect kernel translate it
              assign request_OUT_fifo[i]= (OUT_fifo_data_out[SIZE_TOT_OUT*i+MSB_OUT_0:SIZE_TOT_OUT*i+MSB_OUT_1]!=(i/RATIO) &amp;&amp; !OUT_fifo_empty[i] &amp;&amp; !OUT_fifo_full[(i+RATIO)%NUM_BANK]);

              //if fifo out not full and or there is a request to rotate or the corresponding register has data ready then copy data
              assign OUT_fifo_wr_en[i]= (!OUT_fifo_full[i] &amp;&amp; (request_OUT_fifo[(i+RATIO)%NUM_BANK] || out_status[3*(i+1)-1:3*i]==3'b010 || out_status[3*(i+1)-1:3*i]==3'b101 || M_DataRdy[i]));

              //if there is a request to rotate then that is data in of FIFO_OUT, otherwise is exit of register
              assign OUT_fifo_data_in[SIZE_TOT_OUT*(i+1)-1:SIZE_TOT_OUT*i]=(request_OUT_fifo[(i+RATIO)%NUM_BANK])? OUT_fifo_data_out[SIZE_TOT_OUT*((i+RATIO)%NUM_BANK+1)-1:SIZE_TOT_OUT*((i+RATIO)%NUM_BANK)] : {out_reg[SIZE_TOT_IN*(i+1)-1:SIZE_TOT_IN*(i+1)-BITSIZE_Mout_tag_ram],M_Rdata_ram[BITSIZE_M_Rdata_ram*(i+1)-1:BITSIZE_M_Rdata_ram*i]};

              //if fifo is nonempty and data is in the correct channel (look at the most significant bit of the kernel) then request to go down
              assign request_out[i]=(!OUT_fifo_empty[i] &amp;&amp; OUT_fifo_data_out[SIZE_TOT_OUT*i+MSB_OUT_0:SIZE_TOT_OUT*i+MSB_OUT_1]==(i/RATIO));

              // read if data selected has to go down or to be translated
              assign OUT_fifo_rd_en[i]=(request_OUT_fifo[i] || selector_mux_OUT_fifo_out[i]);
            end
          endgenerate

          generate
          for(i=0; i&lt;NUM_CHANNEL; i=i+1)
            begin
              //arbiter to decide in case of multiple data ready which one go down
              PT_RR_FU #(.BITSIZE_ops(1), .PORTSIZE_ops(RATIO), .BITSIZE_rops(1), .PORTSIZE_rops(RATIO)) RR_fifo_in(.ops(selector_mux_OUT_fifo_out[RATIO*(i+1)-1:RATIO*i]), .ENABLE(1'b1), .clock(clock), .reset(!reset), .rops(request_out[RATIO*(i+1)-1:RATIO*i]));

              //mux for exit, decide which data output of fifo to give on output
              mux_pw_2 #(.BITSIZE_selector(RATIO), .BITSIZE_data(SIZE_TOT_OUT*RATIO), .BITSIZE_out(SIZE_TOT_OUT)) mux_out (.selector(selector_mux_OUT_fifo_out[RATIO*(i+1)-1:RATIO*i]), .data(OUT_fifo_data_out[RATIO*(i+1)*SIZE_TOT_OUT-1:RATIO*i*SIZE_TOT_OUT]), .out(channel_out[SIZE_TOT_OUT*(i+1)-1:SIZE_TOT_OUT*i]));

              //create the packed used to put data toghether into fifo
              assign data_in[SIZE_TOT_IN*(i+1)-1:SIZE_TOT_IN*i]={Min_tag_ram[BITSIZE_Mout_tag_ram*(i+1)-1:BITSIZE_Mout_tag_ram*i], Min_Wdata_ram[BITSIZE_Mout_Wdata_ram*(i+1)-1:BITSIZE_Mout_Wdata_ram*i], Min_data_ram_size[BITSIZE_Mout_data_ram_size*(i+1)-1:BITSIZE_Mout_data_ram_size*i], Min_addr_ram[BITSIZE_Mout_addr_ram*(i+1)-1:BITSIZE_Mout_addr_ram*i], Min_we_ram[BITSIZE_Mout_we_ram*(i+1)-1:BITSIZE_Mout_we_ram*i], Min_oe_ram[BITSIZE_Mout_oe_ram*(i+1)-1:BITSIZE_Mout_oe_ram*i]};

              //check if there is a real request
              assign fifo_notempty[i]=Min_oe_ram[i]||Min_we_ram[i];

              //bind the channel for the output
              assign Mout_Rdata_ram[BITSIZE_M_Rdata_ram*(i+1)-1:BITSIZE_M_Rdata_ram*i]=channel_out[SIZE_TOT_OUT*i+BITSIZE_M_Rdata_ram-1:SIZE_TOT_OUT*i];
              assign Mout_tag[BITSIZE_Mout_tag_ram*(i+1)-1:BITSIZE_Mout_tag_ram*i]=channel_out[SIZE_TOT_OUT*i+BITSIZE_M_Rdata_ram+BITSIZE_Mout_tag_ram-1:SIZE_TOT_OUT*i+BITSIZE_M_Rdata_ram];

              //if or of selector has at least 1 means that there is a data ready coming down
              assign Mout_DataRdy[i]=(|selector_mux_OUT_fifo_out[RATIO*(i+1)-1:RATIO*i]);

              //rd_en send to lower level only if the fifo in this module read their data
              assign request_wait_accepted[i]=(|request_accepted_by_fifo[(i+1)*RATIO-1:i*RATIO]);
            end
          endgenerate

          //output to bank is the merge of out fifo and register
          bus_merger #(.BITSIZE_in1(BITSIZE_Mout_oe_ram*NUM_BANK), .PORTSIZE_in1(2), .BITSIZE_out1(BITSIZE_Mout_oe_ram*NUM_BANK)) bus_merger_Mout_oe_ram (.out1(Mout_oe_ram), .in1({Mout_oe_ram_0, Mout_oe_ram_1}));
          bus_merger #(.BITSIZE_in1(BITSIZE_Mout_we_ram*NUM_BANK), .PORTSIZE_in1(2), .BITSIZE_out1(BITSIZE_Mout_we_ram*NUM_BANK)) bus_merger_Mout_we_ram (.out1(Mout_we_ram), .in1({Mout_we_ram_0, Mout_we_ram_1}));
          bus_merger #(.BITSIZE_in1(BITSIZE_Mout_addr_ram*NUM_BANK), .PORTSIZE_in1(2), .BITSIZE_out1(BITSIZE_Mout_addr_ram*NUM_BANK)) bus_merger_Mout_addr_ram (.out1(Mout_addr_ram), .in1({Mout_addr_ram_0, Mout_addr_ram_1}));
          bus_merger #(.BITSIZE_in1(BITSIZE_Mout_data_ram_size*NUM_BANK), .PORTSIZE_in1(2), .BITSIZE_out1(BITSIZE_Mout_data_ram_size*NUM_BANK)) bus_merger_Mout_data_ram_size (.out1(Mout_data_ram_size), .in1({Mout_data_ram_size_0, Mout_data_ram_size_1}));
          bus_merger #(.BITSIZE_in1(BITSIZE_Mout_Wdata_ram*NUM_BANK), .PORTSIZE_in1(2), .BITSIZE_out1(BITSIZE_Mout_Wdata_ram*NUM_BANK)) bus_merger_Mout_Wdata_ram (.out1(Mout_Wdata_ram), .in1({Mout_Wdata_ram_0, Mout_Wdata_ram_1}));"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
      <name>memory_ctrl_parallel</name>
      <operation operation_name="memory_ctrl_parallel"/>
      <circuit>
        <component_o id="memory_ctrl_parallel">
          <structural_type_descriptor id_type="memory_ctrl_parallel"/>
          <parameter name="NUM_CHANNEL">2</parameter>
          <parameter name="NUM_ACC">4</parameter>
          <parameter name="NUM_TASKS">8</parameter>
          <parameter name="ADDR_TASKS">3</parameter>
          <parameter name="ADDR_ACC">2</parameter>
          <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
          <copyright>Copyright (C) 2004-2017 Politecnico di Milano</copyright>
          <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
          <license>PANDA_LGPLv3</license>
          <port_o id="clock" dir="IN" is_clock="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_o id="reset" dir="IN">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_o>
          <port_vector_o id="IN_M_Rdata_ram" dir="IN" is_memory="1" is_global="1" is_extern="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="IN_Min_tag" dir="IN" is_memory="1" is_global="1" is_extern="1" is_tag_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="IN_M_DataRdy" dir="IN" is_memory="1" is_global="1" is_extern="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="IN_request_accepted" dir="IN" is_memory="1" is_global="1" is_extern="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="Mout_oe_ram" dir="IN" is_memory="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="Mout_we_ram" dir="IN" is_memory="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="Mout_addr_ram" dir="IN" is_memory="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="Mout_data_ram_size" dir="IN" is_memory="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="Mout_Wdata_ram" dir="IN" is_memory="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="Mout_tag_ram" dir="IN" is_memory="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="OUT_Mout_oe_ram" dir="OUT" is_memory="1" is_master="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="OUT_Mout_we_ram" dir="OUT" is_memory="1" is_master="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <port_vector_o id="OUT_Mout_addr_ram" dir="OUT" is_memory="1" is_master="1" is_addr_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="OUT_Mout_data_ram_size" dir="OUT" is_memory="1" is_master="1" is_size_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="OUT_Mout_Wdata_ram" dir="OUT" is_memory="1" is_master="1" is_data_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="OUT_Mout_tag_ram" dir="OUT" is_memory="1" is_master="1" is_tag_bus="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="M_Rdata_ram" dir="OUT" is_memory="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="Min_tag" dir="OUT" is_memory="1">
            <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
          </port_vector_o>
          <port_vector_o id="M_DataRdy" dir="OUT" is_memory="1">
            <structural_type_descriptor type="INT" size="1"/>
          </port_vector_o>
          <port_vector_o id="request_accepted" dir="OUT" is_memory="1">
            <structural_type_descriptor type="BOOL" size="1"/>
          </port_vector_o>
          <NP_functionality LIBRARY="memory_ctrl_parallel IN_M_Rdata_ram IN_Min_tag IN_M_DataRdy Mout_oe_ram Mout_we_ram Mout_addr_ram Mout_data_ram_size Mout_Wdata_ram Mout_tag_ram OUT_Mout_oe_ram OUT_Mout_we_ram OUT_Mout_addr_ram OUT_Mout_data_ram_size OUT_Mout_Wdata_ram OUT_Mout_tag_ram M_Rdata_ram Min_tag M_DataRdy"
          IP_COMPONENT="PT_RR_FU, mux_pw_2" VERILOG_PROVIDED="
          //In order to be generated correctly NUM_CHANNEL&lt;=NUM_ACC and both of them must be a power of 2
          parameter SIZE_TOT_IN = BITSIZE_Mout_tag_ram+BITSIZE_Mout_Wdata_ram+BITSIZE_Mout_data_ram_size+BITSIZE_Mout_addr_ram+BITSIZE_Mout_we_ram+BITSIZE_Mout_oe_ram;
          parameter SIZE_TOT_OUT = BITSIZE_Mout_tag_ram+BITSIZE_M_Rdata_ram;

          parameter RATIO=NUM_ACC/NUM_CHANNEL;
          wire [NUM_ACC-1:0] selector_mux_fifo_in;
          wire [SIZE_TOT_IN*NUM_ACC-1:0] data_in_mem_par;
          wire [NUM_ACC-1:0] fifo_wait_notempty;
          wire [SIZE_TOT_IN*NUM_CHANNEL-1:0] data_in;

          //out of fifo_IN_0 is 0 if fifo is empty
          genvar i;
          generate
          for(i=0; i&lt;NUM_CHANNEL; i=i+1)  //or a x ingressi
          begin
            assign OUT_Mout_oe_ram[(i+1)*BITSIZE_Mout_oe_ram-1:i*BITSIZE_Mout_oe_ram]=(|fifo_wait_notempty[(i+1)*RATIO-1:i*RATIO])? data_in[SIZE_TOT_IN*i+BITSIZE_Mout_oe_ram-1] : {BITSIZE_Mout_oe_ram{1'b0}};
            assign OUT_Mout_we_ram[(i+1)*BITSIZE_Mout_we_ram-1:i*BITSIZE_Mout_we_ram]=(|fifo_wait_notempty[(i+1)*RATIO-1:i*RATIO])? data_in[SIZE_TOT_IN*i+BITSIZE_Mout_we_ram + BITSIZE_Mout_oe_ram-1] : {BITSIZE_Mout_we_ram{1'b0}};
            assign OUT_Mout_addr_ram[(i+1)*BITSIZE_Mout_addr_ram-1:i*BITSIZE_Mout_addr_ram]=(|fifo_wait_notempty[(i+1)*RATIO-1:i*RATIO])? data_in[SIZE_TOT_IN*i+BITSIZE_Mout_addr_ram + BITSIZE_Mout_we_ram + BITSIZE_Mout_oe_ram-1:SIZE_TOT_IN*i+BITSIZE_Mout_we_ram + BITSIZE_Mout_oe_ram] : {BITSIZE_Mout_addr_ram{1'b0}};
            assign OUT_Mout_data_ram_size[(i+1)*BITSIZE_Mout_data_ram_size-1:i*BITSIZE_Mout_data_ram_size]=(|fifo_wait_notempty[(i+1)*RATIO-1:i*RATIO])? data_in[SIZE_TOT_IN*i+BITSIZE_Mout_data_ram_size + BITSIZE_Mout_addr_ram + BITSIZE_Mout_we_ram + BITSIZE_Mout_oe_ram-1:SIZE_TOT_IN*i+BITSIZE_Mout_addr_ram + BITSIZE_Mout_we_ram + BITSIZE_Mout_oe_ram] : {BITSIZE_Mout_data_ram_size{1'b0}};
            assign OUT_Mout_Wdata_ram[(i+1)*BITSIZE_Mout_Wdata_ram-1:i*BITSIZE_Mout_Wdata_ram]=(|fifo_wait_notempty[(i+1)*RATIO-1:i*RATIO])? data_in[SIZE_TOT_IN*i+BITSIZE_Mout_Wdata_ram + BITSIZE_Mout_data_ram_size + BITSIZE_Mout_addr_ram + BITSIZE_Mout_we_ram + BITSIZE_Mout_oe_ram-1:SIZE_TOT_IN*i+BITSIZE_Mout_data_ram_size + BITSIZE_Mout_addr_ram + BITSIZE_Mout_we_ram + BITSIZE_Mout_oe_ram] : {BITSIZE_Mout_Wdata_ram{1'b0}};
            assign OUT_Mout_tag_ram[(i+1)*BITSIZE_Mout_tag_ram-1:i*BITSIZE_Mout_tag_ram]=(|fifo_wait_notempty[(i+1)*RATIO-1:i*RATIO])? {1'b1,data_in[SIZE_TOT_IN*i+BITSIZE_Mout_tag_ram + BITSIZE_Mout_Wdata_ram + BITSIZE_Mout_data_ram_size + BITSIZE_Mout_addr_ram + BITSIZE_Mout_we_ram + BITSIZE_Mout_oe_ram-2:SIZE_TOT_IN*i+BITSIZE_Mout_Wdata_ram + BITSIZE_Mout_data_ram_size + BITSIZE_Mout_addr_ram + BITSIZE_Mout_we_ram + BITSIZE_Mout_oe_ram]} : {BITSIZE_Mout_tag_ram{1'b0}};   //every data out has 1 as first bit of tag

            //arbiter for decide which data go to memory
            PT_RR_FU #(.BITSIZE_ops(1), .PORTSIZE_ops(RATIO), .BITSIZE_rops(1), .PORTSIZE_rops(RATIO)) RR_fifo_in_0(.ops(selector_mux_fifo_in[RATIO*(i+1)-1:RATIO*i]), .ENABLE(1'b1), .clock(clock), .reset(!reset), .rops(fifo_wait_notempty[RATIO*(i+1)-1:RATIO*i]));

            //assign tag out
            assign Mout_tag[BITSIZE_Mout_tag_ram*(i+1)-1:BITSIZE_Mout_tag_ram*i]={1'b0,IN_Min_tag[BITSIZE_Mout_tag_ram*(i+1)-2:BITSIZE_Mout_tag_ram*i]};

            //BIND in of IN_fifo_in       //MUX with n in
            mux_pw_2 #(.BITSIZE_selector(RATIO), .BITSIZE_data(SIZE_TOT_IN*RATIO), .BITSIZE_out(SIZE_TOT_IN)) mux_in (.selector(selector_mux_fifo_in[RATIO*(i+1)-1:RATIO*i]), .data(data_in_mem_par[SIZE_TOT_IN*((i+1)*RATIO)-1:SIZE_TOT_IN*(i*RATIO)]), .out(data_in[SIZE_TOT_IN*(i+1)-1:SIZE_TOT_IN*i]));
          end
          endgenerate

          generate
          for(i=0; i&lt;NUM_ACC; i=i+1)
            begin
              //check if there is a real request
              assign fifo_wait_notempty[i]=Mout_oe_ram[i]||Mout_we_ram[i];

              //reconstruct block from input
              assign data_in_mem_par[SIZE_TOT_IN*(i+1)-1:SIZE_TOT_IN*i]={Mout_tag_ram[BITSIZE_Mout_tag_ram*(i+1)-1:BITSIZE_Mout_tag_ram*i], Mout_Wdata_ram[BITSIZE_Mout_Wdata_ram*(i+1)-1:BITSIZE_Mout_Wdata_ram*i], Mout_data_ram_size[BITSIZE_Mout_data_ram_size*(i+1)-1:BITSIZE_Mout_data_ram_size*i], Mout_addr_ram[BITSIZE_Mout_addr_ram*(i+1)-1:BITSIZE_Mout_addr_ram*i], Mout_we_ram[BITSIZE_Mout_we_ram*(i+1)-1:BITSIZE_Mout_we_ram*i], Mout_oe_ram[BITSIZE_Mout_oe_ram*(i+1)-1:BITSIZE_Mout_oe_ram*i]};

              //ack that is the rd_en on the scheduler, if fifo not empty push down data    //POSSIBLE TO DO REST
              assign M_DataRdy[i]=(IN_M_DataRdy[i/RATIO] &amp;&amp; IN_Min_tag[BITSIZE_Mout_tag_ram*(i/RATIO)+ADDR_TASKS+ADDR_ACC-1:BITSIZE_Mout_tag_ram*(i/RATIO)+ADDR_TASKS]==i &amp;&amp; IN_Min_tag[BITSIZE_Mout_tag_ram*(i/RATIO+1)-1]);

              //ack on the appropriate kernel if its request is accepted
              assign request_accepted[i] =(IN_request_accepted[(i/RATIO)] &amp;&amp; fifo_wait_notempty[i] &amp;&amp; selector_mux_fifo_in[i]==1'b1);
            end
          endgenerate

          //BIND out of OUT_fifo_out
          assign M_Rdata_ram= IN_M_Rdata_ram;"/>
        </component_o>
      </circuit>
    </cell>
    <cell>
    <name>mux_pw_2</name>
    <operation operation_name="mux_pw_2"/>
    <circuit>
      <component_o id="mux_pw_2">
        <structural_type_descriptor id_type="mux_pw_2"/>
        <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
        <copyright>Copyright (C) 2004-2017 Politecnico di Milano</copyright>
        <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
        <license>PANDA_LGPLv3</license>
        <port_o id="data" dir="IN" is_clock="1">
          <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
        </port_o>
        <port_o id="selector" dir="IN">
          <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
        </port_o>
        <port_o id="out" dir="OUT">
          <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
        </port_o>
        <NP_functionality LIBRARY="mux_pw_2 data selector out" VERILOG_PROVIDED="
        //BITSIZE_selector must be a power of 2
        parameter DATA_SIZE=BITSIZE_out;

        generate
          if(BITSIZE_selector==1) begin
            assign out=data;
          end
          if(BITSIZE_selector==2) begin
            assign out=(selector[1:0]==2'b01)?data[DATA_SIZE-1:0]:data[DATA_SIZE*2-1:DATA_SIZE];
          end
          if(BITSIZE_selector==4) begin
            wire [DATA_SIZE-1:0] mux1;
            wire [DATA_SIZE-1:0] mux2;
            wire sel1;
            //level 0
            assign mux1=(selector[1:0]==2'b01)?data[DATA_SIZE-1:0]:data[DATA_SIZE*2-1:DATA_SIZE];
            assign mux2=(selector[3:2]==2'b01)?data[DATA_SIZE*3-1:DATA_SIZE*2]:data[DATA_SIZE*4-1:DATA_SIZE*3];
            assign sel1=|selector[1:0];
            //level 1
            assign out=(sel1)?mux1:mux2;
          end
          if(BITSIZE_selector==8) begin
            wire [DATA_SIZE-1:0] mux1;
            wire [DATA_SIZE-1:0] mux2;
            wire [DATA_SIZE-1:0] mux3;
            wire [DATA_SIZE-1:0] mux4;
            wire sel1;
            wire sel2;
            wire [DATA_SIZE-1:0] mux11;
            wire [DATA_SIZE-1:0] mux12;
            wire sel11;
            //level 0
            assign mux1=(selector[1:0]==2'b01)?data[DATA_SIZE-1:0]:data[DATA_SIZE*2-1:DATA_SIZE];
            assign mux2=(selector[3:2]==2'b01)?data[DATA_SIZE*3-1:DATA_SIZE*2]:data[DATA_SIZE*4-1:DATA_SIZE*3];
            assign mux3=(selector[5:4]==2'b01)?data[DATA_SIZE*5-1:DATA_SIZE*4]:data[DATA_SIZE*6-1:DATA_SIZE*5];
            assign mux4=(selector[7:6]==2'b01)?data[DATA_SIZE*7-1:DATA_SIZE*6]:data[DATA_SIZE*8-1:DATA_SIZE*7];
            assign sel1=|selector[1:0];
            assign sel2=|selector[5:4];
            //level 1
            assign mux11=(sel1)?mux1:mux2;
            assign mux12=(sel2)?mux3:mux4;
            assign sel11=|selector[3:0];
            //level 2
            assign out=(sel11)?mux11:mux12;
          end
          if(BITSIZE_selector==16) begin
            wire [DATA_SIZE-1:0] mux1;
            wire [DATA_SIZE-1:0] mux2;
            wire [DATA_SIZE-1:0] mux3;
            wire [DATA_SIZE-1:0] mux4;
            wire [DATA_SIZE-1:0] mux5;
            wire [DATA_SIZE-1:0] mux6;
            wire [DATA_SIZE-1:0] mux7;
            wire [DATA_SIZE-1:0] mux8;
            wire sel1;
            wire sel2;
            wire sel3;
            wire sel4;
            wire [DATA_SIZE-1:0] mux11;
            wire [DATA_SIZE-1:0] mux12;
            wire [DATA_SIZE-1:0] mux13;
            wire [DATA_SIZE-1:0] mux14;
            wire sel11;
            wire sel12;
            wire [DATA_SIZE-1:0] mux21;
            wire [DATA_SIZE-1:0] mux22;
            wire sel21;
            //level 0
            assign mux1=(selector[1:0]==2'b01)?data[DATA_SIZE-1:0]:data[DATA_SIZE*2-1:DATA_SIZE];
            assign mux2=(selector[3:2]==2'b01)?data[DATA_SIZE*3-1:DATA_SIZE*2]:data[DATA_SIZE*4-1:DATA_SIZE*3];
            assign mux3=(selector[5:4]==2'b01)?data[DATA_SIZE*5-1:DATA_SIZE*4]:data[DATA_SIZE*6-1:DATA_SIZE*5];
            assign mux4=(selector[7:6]==2'b01)?data[DATA_SIZE*7-1:DATA_SIZE*6]:data[DATA_SIZE*8-1:DATA_SIZE*7];
            assign mux5=(selector[9:8]==2'b01)?data[DATA_SIZE*9-1:DATA_SIZE*8]:data[DATA_SIZE*10-1:DATA_SIZE*9];
            assign mux6=(selector[11:10]==2'b01)?data[DATA_SIZE*11-1:DATA_SIZE*10]:data[DATA_SIZE*12-1:DATA_SIZE*11];
            assign mux7=(selector[13:12]==2'b01)?data[DATA_SIZE*13-1:DATA_SIZE*12]:data[DATA_SIZE*14-1:DATA_SIZE*13];
            assign mux8=(selector[15:14]==2'b01)?data[DATA_SIZE*15-1:DATA_SIZE*14]:data[DATA_SIZE*16-1:DATA_SIZE*15];
            assign sel1=|selector[1:0];
            assign sel2=|selector[5:4];
            assign sel3=|selector[9:8];
            assign sel4=|selector[13:12];
            //level 1
            assign mux11=(sel1)?mux1:mux2;
            assign mux12=(sel2)?mux3:mux4;
            assign mux13=(sel3)?mux5:mux6;
            assign mux14=(sel4)?mux7:mux8;
            assign sel11=|selector[3:0];
            assign sel12=|selector[11:8];
            //level 2
            assign mux21=(sel11)?mux11:mux12;
            assign mux22=(sel12)?mux13:mux14;
            assign sel21=|selector[7:0];
            //level 3
            assign out=(sel21)?mux21:mux22;
          end
          if(BITSIZE_selector==32) begin
            wire [DATA_SIZE-1:0] mux1;
            wire [DATA_SIZE-1:0] mux2;
            wire [DATA_SIZE-1:0] mux3;
            wire [DATA_SIZE-1:0] mux4;
            wire [DATA_SIZE-1:0] mux5;
            wire [DATA_SIZE-1:0] mux6;
            wire [DATA_SIZE-1:0] mux7;
            wire [DATA_SIZE-1:0] mux8;
            wire [DATA_SIZE-1:0] mux9;
            wire [DATA_SIZE-1:0] mux10;
            wire [DATA_SIZE-1:0] mux11;
            wire [DATA_SIZE-1:0] mux12;
            wire [DATA_SIZE-1:0] mux13;
            wire [DATA_SIZE-1:0] mux14;
            wire [DATA_SIZE-1:0] mux15;
            wire [DATA_SIZE-1:0] mux16;
            wire sel1;
            wire sel2;
            wire sel3;
            wire sel4;
            wire sel5;
            wire sel6;
            wire sel7;
            wire sel8;
            wire [DATA_SIZE-1:0] mux21;
            wire [DATA_SIZE-1:0] mux22;
            wire [DATA_SIZE-1:0] mux23;
            wire [DATA_SIZE-1:0] mux24;
            wire [DATA_SIZE-1:0] mux25;
            wire [DATA_SIZE-1:0] mux26;
            wire [DATA_SIZE-1:0] mux27;
            wire [DATA_SIZE-1:0] mux28;
            wire sel21;
            wire sel22;
            wire sel23;
            wire sel24;
            wire [DATA_SIZE-1:0] mux31;
            wire [DATA_SIZE-1:0] mux32;
            wire [DATA_SIZE-1:0] mux33;
            wire [DATA_SIZE-1:0] mux34;
            wire sel31;
            wire sel32;
            wire [DATA_SIZE-1:0] mux41;
            wire [DATA_SIZE-1:0] mux42;
            wire sel41;
            //level 0
            assign mux1=(selector[1:0]==2'b01)?data[DATA_SIZE-1:0]:data[DATA_SIZE*2-1:DATA_SIZE];
            assign mux2=(selector[3:2]==2'b01)?data[DATA_SIZE*3-1:DATA_SIZE*2]:data[DATA_SIZE*4-1:DATA_SIZE*3];
            assign mux3=(selector[5:4]==2'b01)?data[DATA_SIZE*5-1:DATA_SIZE*4]:data[DATA_SIZE*6-1:DATA_SIZE*5];
            assign mux4=(selector[7:6]==2'b01)?data[DATA_SIZE*7-1:DATA_SIZE*6]:data[DATA_SIZE*8-1:DATA_SIZE*7];
            assign mux5=(selector[9:8]==2'b01)?data[DATA_SIZE*9-1:DATA_SIZE*8]:data[DATA_SIZE*10-1:DATA_SIZE*9];
            assign mux6=(selector[11:10]==2'b01)?data[DATA_SIZE*11-1:DATA_SIZE*10]:data[DATA_SIZE*12-1:DATA_SIZE*11];
            assign mux7=(selector[13:12]==2'b01)?data[DATA_SIZE*13-1:DATA_SIZE*12]:data[DATA_SIZE*14-1:DATA_SIZE*13];
            assign mux8=(selector[15:14]==2'b01)?data[DATA_SIZE*15-1:DATA_SIZE*14]:data[DATA_SIZE*16-1:DATA_SIZE*15];
            assign mux9=(selector[17:16]==2'b01)?data[DATA_SIZE*17-1:DATA_SIZE*16]:data[DATA_SIZE*18-1:DATA_SIZE*17];
            assign mux10=(selector[19:18]==2'b01)?data[DATA_SIZE*19-1:DATA_SIZE*18]:data[DATA_SIZE*20-1:DATA_SIZE*19];
            assign mux11=(selector[21:20]==2'b01)?data[DATA_SIZE*21-1:DATA_SIZE*20]:data[DATA_SIZE*22-1:DATA_SIZE*21];
            assign mux12=(selector[23:22]==2'b01)?data[DATA_SIZE*23-1:DATA_SIZE*22]:data[DATA_SIZE*24-1:DATA_SIZE*23];
            assign mux13=(selector[25:24]==2'b01)?data[DATA_SIZE*25-1:DATA_SIZE*24]:data[DATA_SIZE*26-1:DATA_SIZE*25];
            assign mux14=(selector[27:26]==2'b01)?data[DATA_SIZE*27-1:DATA_SIZE*26]:data[DATA_SIZE*28-1:DATA_SIZE*27];
            assign mux15=(selector[29:28]==2'b01)?data[DATA_SIZE*29-1:DATA_SIZE*28]:data[DATA_SIZE*30-1:DATA_SIZE*29];
            assign mux16=(selector[31:30]==2'b01)?data[DATA_SIZE*31-1:DATA_SIZE*30]:data[DATA_SIZE*32-1:DATA_SIZE*31];
            assign sel1=|selector[1:0];
            assign sel2=|selector[5:4];
            assign sel3=|selector[9:8];
            assign sel4=|selector[13:12];
            assign sel5=|selector[17:16];
            assign sel6=|selector[21:20];
            assign sel7=|selector[25:24];
            assign sel8=|selector[29:28];
            //level 1
            assign mux21=(sel1)?mux1:mux2;
            assign mux22=(sel2)?mux3:mux4;
            assign mux23=(sel3)?mux5:mux6;
            assign mux24=(sel4)?mux7:mux8;
            assign mux25=(sel5)?mux9:mux10;
            assign mux26=(sel6)?mux11:mux12;
            assign mux27=(sel7)?mux13:mux14;
            assign mux28=(sel8)?mux15:mux16;
            assign sel21=|selector[3:0];
            assign sel22=|selector[11:8];
            assign sel23=|selector[19:16];
            assign sel24=|selector[27:24];
            //level 2
            assign mux31=(sel21)?mux21:mux22;
            assign mux32=(sel22)?mux23:mux24;
            assign mux33=(sel23)?mux25:mux26;
            assign mux34=(sel24)?mux27:mux28;
            assign sel31=|selector[7:0];
            assign sel32=|selector[23:16];
            //level 3
            assign mux41=(sel31)?mux31:mux32;
            assign mux42=(sel32)?mux33:mux34;
            assign sel41=|selector[15:0];
            //level 4
            assign out=(sel41)?mux41:mux42;
          end
        endgenerate"/>
      </component_o>
    </circuit>
  </cell>
  <cell>
  <name>controller_parallel</name>
  <operation operation_name="controller_parallel"/>
  <circuit>
    <component_o id="controller_parallel">
      <structural_type_descriptor id_type="controller_parallel"/>
      <description>This component is part of the BAMBU/PANDA IP LIBRARY</description>
      <copyright>Copyright (C) 2004-2017 Politecnico di Milano</copyright>
      <authors>Fabrizio Ferrandi &lt;fabrizio.ferrandi@polimi.it&gt;</authors>
      <license>PANDA_LGPLv3</license>
      <port_o id="clock" dir="IN" is_clock="1">
        <structural_type_descriptor type="BOOL" size="1"/>
      </port_o>
      <port_o id="reset" dir="IN">
        <structural_type_descriptor type="BOOL" size="1"/>
      </port_o>
      <port_o id="start_port" dir="IN">
        <structural_type_descriptor type="BOOL" size="1"/>
      </port_o>
      <port_o id="done_port_accelerator" dir="IN" is_clock="1">
        <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
      </port_o>
      <port_o id="done_request_accelerator" dir="IN">
        <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
      </port_o>
      <port_o id="LoopIteration" dir="IN">
        <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
      </port_o>
      <port_o id="done_port" dir="OUT">
        <structural_type_descriptor type="BOOL" size="1"/>
      </port_o>
      <port_o id="task_finished" dir="OUT">
        <structural_type_descriptor type="BOOL" size="1"/>
      </port_o>
      <port_o id="start_port_accelerator" dir="OUT">
        <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
      </port_o>
      <port_o id="request" dir="OUT">
        <structural_type_descriptor type="VECTOR_BOOL" size="1" vector_size="1"/>
      </port_o>
      <NP_functionality LIBRARY="controller_parallel done_port_accelerator done_request_accelerator start_port_accelerator"
      IP_COMPONENT="ui_ne_expr_FU, read_cond_FU, register_SE, fifo, CallDispatcher, Counter, MUX_GATE, UUdata_converter_FU, constant_value, ASSIGN_UNSIGNED_FU, ui_plus_expr_FU" VERILOG_PROVIDED="
        parameter [2:0] S_0 = 3'd0,
          S_1 = 3'd1,
          S_4 = 3'd4,
          S_5 = 3'd5,
          S_6 = 3'd6,
          S_2 = 3'd2,
          S_3 = 3'd3;
        reg [2:0] _present_state, _next_state;
        reg done_port;
        reg wrenable_reg_1;
        reg wrenable_reg_0;
        reg selector_MUX_2_reg_0_0_0_0;
        reg selector_IN_UNBOUNDED_parallel_18797_18995;
        reg [BITSIZE_start_port_accelerator-1:0]            worker_status;          // To CallDispatcher_i0 of CallDispatcher.v

        wire [31:0] out_MUX_2_reg_0_0_0_0;
        wire out_const_0;
        wire out_const_1;
        wire [31:0]   out_conv_out_u_assign_conn_obj_0_ASSIGN_UNSIGNED_FU_u_assign_0_1_32;
        wire out_read_cond_FU_5_i0_fu_parallel_18797_19050;
        wire [31:0] out_reg_0_reg_0;
        wire [31:0] out_reg_1_reg_1;
        wire [0:0] out_u_assign_conn_obj_0_ASSIGN_UNSIGNED_FU_u_assign_0;
        wire out_ui_ne_expr_FU_32_32_32_7_i0_fu_parallel_18797_19732;
        wire [31:0] out_ui_plus_expr_FU_32_0_32_8_i0_fu_parallel_18797_18996;
        wire [31:0]          fifo_data_out;          // From fifo_i0 of fifo.v
        wire fifo_empty;             // From fifo_i0 of fifo.v
        wire fifo_full;              // keep name fifo_full
        wire completed;              // added
        wire OUT_CONDITION_parallel_18797_19050; //added
        wire fifo_rd_cs;             // From CallDispatcher_i0 of CallDispatcher.v
        wire fifo_rd_en;             // From CallDispatcher_i0 of CallDispatcher.v
        wire [31:0] DoneCounter_value;      // From DoneCounter of Counter.v
        wire [31:0] StartCounter_value;     // From StartCounter of Counter.v
        wire [31:0] number_req_tasks;
        wire [31:0]          request;    // From CallDispatcher_i0 of CallDispatcher.v
        wire OUT_UNBOUNDED_parallel_18797_18995;
        wire [BITSIZE_start_port_accelerator-1:0] selected_worker;        // From CallDispatcher_i0 of CallDispatcher.v
        reg reset_counter;
        reg next_reset_counter;

        always @(posedge clock)
          if (!reset) _present_state &lt;= S_0;
          else _present_state &lt;= _next_state;

        always @(*)
        begin
          _next_state = S_0;
          done_port = 1'b0;
          wrenable_reg_1 = 1'b0;
          wrenable_reg_0 = 1'b0;
          selector_MUX_2_reg_0_0_0_0 = 1'b0;
          selector_IN_UNBOUNDED_parallel_18797_18995 = 1'b0;
          case (_present_state)
            S_0 :
              if(start_port != 1'b1 )
              begin
                _next_state = S_0;
              end
              else
              begin
                _next_state = S_1;
              end
            S_1 :
              begin
                wrenable_reg_0 = 1'b1;
                _next_state = S_4;
              end
            S_4 :
              begin
                wrenable_reg_1 = 1'b1;
                if ((out_read_cond_FU_5_i0_fu_parallel_18797_19050 == 1'b1) &amp; (fifo_full == 1'b0))
                  begin
                    _next_state = S_2;
                  end
                else if (fifo_full == 1'b1)
                  begin
                    _next_state = S_3;
                    wrenable_reg_1 = 1'b0;
                  end
                else
                  begin
                    _next_state = S_6;
                  end
              end
            S_5 :
              begin
                _next_state = S_0;
              end
            S_6 :
              begin
                _next_state = S_6;
                if (completed) begin
                    _next_state = S_5;
                    done_port = 1'b1;
                    wrenable_reg_1 = 1'b0;
                end
              end
            S_2 :
              begin
                wrenable_reg_0 = 1'b1;
                selector_MUX_2_reg_0_0_0_0 = 1'b1;
                selector_IN_UNBOUNDED_parallel_18797_18995 = 1'b1;
      //          if (OUT_UNBOUNDED_parallel_18797_18995 == 1'b0)
                if (fifo_full == 1'b1)
                  begin
                    _next_state = S_3;
                    wrenable_reg_0 = 1'b0;
                    selector_MUX_2_reg_0_0_0_0 = 1'b0;
                  end
                else
                  begin
                    _next_state = S_4;
                  end
              end
            S_3 :
              begin
                wrenable_reg_0 = 1'b1;
                selector_MUX_2_reg_0_0_0_0 = 1'b1;
      //          if (OUT_UNBOUNDED_parallel_18797_18995 == 1'b0)
                if (fifo_full == 1'b1)
                  begin
                    _next_state = S_3;
                    wrenable_reg_0 = 1'b0;
                    selector_MUX_2_reg_0_0_0_0 = 1'b0;
                  end
                else
                  begin
                    _next_state = S_4;
                  end
              end
            default :
              begin
                done_port = 1'b0;
                wrenable_reg_1 = 1'b0;
                wrenable_reg_0 = 1'b0;
                selector_MUX_2_reg_0_0_0_0 = 1'b0;
                selector_IN_UNBOUNDED_parallel_18797_18995 = 1'b0;
              end
          endcase
        end

        ui_ne_expr_FU #(.BITSIZE_in1(32), .BITSIZE_in2(32), .BITSIZE_out1(1)) fu_parallel_18797_19732(
        .out1(out_ui_ne_expr_FU_32_32_32_7_i0_fu_parallel_18797_19732),
        .in1(out_reg_0_reg_0),
        .in2(LoopIteration));

        read_cond_FU #(.BITSIZE_in1(1)) fu_parallel_18797_19050(
        .out1(out_read_cond_FU_5_i0_fu_parallel_18797_19050),
        .in1(out_ui_ne_expr_FU_32_32_32_7_i0_fu_parallel_18797_19732));

        register_SE #(.BITSIZE_in1(32), .BITSIZE_out1(32)) reg_0 (
        .out1(out_reg_0_reg_0),
        .clock(clock),
        .reset(reset),
        .in1(out_MUX_2_reg_0_0_0_0),
        .wenable(wrenable_reg_0));

        fifo #(.DATA_WIDTH(32), .ADDR_WIDTH(10)) fifo_i0
         (/*AUTOINST*/
          // Outputs
          .full                             (fifo_full),             // Templated
          .empty                            (fifo_empty),            // Templated
          .data_out                         (fifo_data_out[31:0]),   // Templated
          // Inputs
          .clk                              (clock),                 // Templated
          .rst                              (!reset),                // Templated
          .wr_cs                            (selector_IN_UNBOUNDED_parallel_18797_18995),            // Templated
          .rd_cs                            (fifo_rd_cs),            // Templated
          .rd_en                            (fifo_rd_en),            // Templated
          .wr_en                            (selector_IN_UNBOUNDED_parallel_18797_18995),            // Templated
          .data_in                          (out_reg_0_reg_0));               // Templated

        CallDispatcher #(.WORKERS(4), .BITSIZE_REQUEST(32)) CallDispatcher_i0
         (/*AUTOINST*/
          // Outputs
          .fifo_rd_cs                       (fifo_rd_cs),
          .fifo_rd_en                       (fifo_rd_en),
          .request                          (request),
          .selected_worker                  (selected_worker),
          // Inputs
          .clock                            (clock),
          .reset                            (reset),
          .fifo_data_out                    (fifo_data_out),
          .fifo_empty                       (fifo_empty),
          .worker_status                    (worker_status));

        Counter #(.BITSIZE_COUNTER(32), .DRIVERS(1)) StartCounter (
        /*AUTOINST*/
        // Outputs
        .value             (StartCounter_value), // Templated
        // Inputs
        .clock              (clock),                 // Templated
        .reset              (reset_counter),         // Templated
        .driver_lines   (selector_IN_UNBOUNDED_parallel_18797_18995));            // Templated

        Counter #(.BITSIZE_COUNTER(32), .DRIVERS(BITSIZE_start_port_accelerator)) DoneCounter(
        /*AUTOINST*/
        // Outputs
        .value                         (DoneCounter_value), // Templated
        // Inputs
        .clock                         (clock),                 // Templated
        .reset                         (reset_counter),         // Templated
        .driver_lines                  (done_port_accelerator)); // Templated

        // done request counter
        Counter #(.BITSIZE_COUNTER(32), .DRIVERS(BITSIZE_start_port_accelerator)) DoneReqCounter(
        /*AUTOINST*/
        // Outputs
        .value (number_req_tasks), // Templated
        // Inputs
        .clock (clock),                 // Templated
        .reset (reset_counter),         // Templated
        .driver_lines (selected_worker)); // Templated

        MUX_GATE #(.BITSIZE_in1(32), .BITSIZE_in2(32), .BITSIZE_out1(32)) MUX_2_reg_0_0_0_0 (.out1(out_MUX_2_reg_0_0_0_0), .sel(selector_MUX_2_reg_0_0_0_0), .in1(out_reg_1_reg_1), .in2(out_conv_out_u_assign_conn_obj_0_ASSIGN_UNSIGNED_FU_u_assign_0_1_32));

        always @(posedge clock or negedge reset)
          if (!reset)
            reset_counter &lt;= 1'b0;
          else
            reset_counter &lt;= next_reset_counter;

        always @(*) next_reset_counter = ~completed;

        assign completed = fifo_empty &amp; (StartCounter_value == DoneCounter_value) &amp; (| StartCounter_value) &amp; (| DoneCounter_value);

        assign task_finished = (number_req_tasks == StartCounter_value) &amp; (| StartCounter_value) &amp; (| number_req_tasks);

        register_SE #(.BITSIZE_in1(32), .BITSIZE_out1(32)) reg_1 (
        .out1(out_reg_1_reg_1),
        .clock(clock), .reset(reset),
        .in1(out_ui_plus_expr_FU_32_0_32_8_i0_fu_parallel_18797_18996),
        .wenable(wrenable_reg_1));

        UUdata_converter_FU #(.BITSIZE_in1(1), .BITSIZE_out1(32)) conv_out_u_assign_conn_obj_0_ASSIGN_UNSIGNED_FU_u_assign_0_1_32 (.out1(out_conv_out_u_assign_conn_obj_0_ASSIGN_UNSIGNED_FU_u_assign_0_1_32), .in1(out_u_assign_conn_obj_0_ASSIGN_UNSIGNED_FU_u_assign_0));

        ASSIGN_UNSIGNED_FU #(.BITSIZE_in1(1), .BITSIZE_out1(1)) ASSIGN_UNSIGNED_FU_u_assign_0 (.out1(out_u_assign_conn_obj_0_ASSIGN_UNSIGNED_FU_u_assign_0), .in1(out_const_0));

        //assign OUT_UNBOUNDED_parallel_18797_18995 = selector_IN_UNBOUNDED_parallel_18797_18995 &amp; !fifo_full;

        constant_value #(.BITSIZE_out1(1), .value(1'b0)) const_0 (.out1(out_const_0));
        constant_value #(.BITSIZE_out1(1), .value(1'b1)) const_1 (.out1(out_const_1));


      // Worker status register
        reg [3:0] next_worker_status;
         always @(posedge clock or negedge reset) begin
            if (!reset)
              worker_status &lt;= {BITSIZE_start_port_accelerator{1'b0}};
            else
              worker_status &lt;= next_worker_status;
         end
        always @(*) begin
          next_worker_status = worker_status;
        end

        generate
          for(i=0; i&lt;NUM_CHANNEL; i=i+1)  //or a x ingressi
          begin
            always @(*) begin
              if (selected_worker[i])
                next_worker_status[i] =1'b1;
              if (done_request_accelerator[i])
                next_worker_status[i] =1'b0;
            end
          end
        endgenerate

        ui_plus_expr_FU #(.BITSIZE_in1(32), .BITSIZE_in2(1), .BITSIZE_out1(32)) fu_parallel_18797_18996(
        .out1(out_ui_plus_expr_FU_32_0_32_8_i0_fu_parallel_18797_18996),
        .in1(out_reg_0_reg_0), .in2(out_const_1));

        assign start_port_accelerator = selected_worker;  //bind start_port"/>
        </component_o>
      </circuit>
    </cell>
  </library>
</technology>

